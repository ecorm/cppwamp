<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppWAMP: wamp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppWAMP
   </div>
   <div id="projectbrief">C++11 client library for the WAMP protocol</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacewamp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">wamp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacewamp_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_abort.html">Abort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <em>reason</em> URI and other options contained within <code>ABORT</code> messages.  <a href="classwamp_1_1_abort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_any_reusable_handler.html">AnyReusableHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erases a multi-shot, copyable callback handler.  <a href="classwamp_1_1_any_reusable_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_authentication.html">Authentication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <em>Signature</em> and <em>Extra</em> dictionary contained within WAMP <code>AUTHENTICATE</code> messages.  <a href="classwamp_1_1_authentication.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_cbor_decoder.html">BasicCborDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR decoder.  <a href="classwamp_1_1_basic_cbor_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_cbor_decoder_3_01_i_00_01_stream_input_category_01_4.html">BasicCborDecoder&lt; I, StreamInputCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR decoder specialization for stream inputs.  <a href="classwamp_1_1_basic_cbor_decoder_3_01_i_00_01_stream_input_category_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_cbor_encoder.html">BasicCborEncoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR encoder.  <a href="classwamp_1_1_basic_cbor_encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_cbor_encoder_3_01_o_00_01_stream_output_category_01_4.html">BasicCborEncoder&lt; O, StreamOutputCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR encoder specialization for streams.  <a href="classwamp_1_1_basic_cbor_encoder_3_01_o_00_01_stream_output_category_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_json_decoder.html">BasicJsonDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON decoder.  <a href="classwamp_1_1_basic_json_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_json_decoder_3_01_i_00_01_stream_input_category_01_4.html">BasicJsonDecoder&lt; I, StreamInputCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON decoder specialization for stream inputs.  <a href="classwamp_1_1_basic_json_decoder_3_01_i_00_01_stream_input_category_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_json_encoder.html">BasicJsonEncoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON encoder.  <a href="classwamp_1_1_basic_json_encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_msgpack_decoder.html">BasicMsgpackDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoder specialization for <a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a>.  <a href="classwamp_1_1_basic_msgpack_decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_msgpack_decoder_3_01_i_00_01_stream_input_category_01_4.html">BasicMsgpackDecoder&lt; I, StreamInputCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decoder specialization for <a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> and stream inputs.  <a href="classwamp_1_1_basic_msgpack_decoder_3_01_i_00_01_stream_input_category_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_msgpack_encoder.html">BasicMsgpackEncoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> encoder.  <a href="classwamp_1_1_basic_msgpack_encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_basic_msgpack_encoder_3_01_o_00_01_stream_output_category_01_4.html">BasicMsgpackEncoder&lt; O, StreamOutputCategory &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> encoder specialization for streams.  <a href="classwamp_1_1_basic_msgpack_encoder_3_01_o_00_01_stream_output_category_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_blob.html">Blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains binary data as an array of bytes.  <a href="classwamp_1_1_blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_byte_array_input_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_byte_array_input_category">ByteArrayInputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_byte_array_input_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input category for contiguous byte arrays which provide <code>data</code> and <code>size</code> member functions.  <a href="namespacewamp.html#structwamp_1_1_byte_array_input_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_byte_array_input_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_byte_container_output_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_byte_container_output_category">ByteContainerOutputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_byte_container_output_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output category for containers of bytes which provide <code>push_back</code> and <code>insert</code> member functions.  <a href="namespacewamp.html#structwamp_1_1_byte_container_output_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_byte_container_output_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_call_cancellation.html">CallCancellation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the request ID and options contained within WAMP <code>CANCEL</code> messages.  <a href="classwamp_1_1_call_cancellation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_call_chit.html">CallChit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lightweight token representing a call request.  <a href="classwamp_1_1_call_chit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_cbor.html">Cbor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR format tag type.  <a href="structwamp_1_1_cbor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_challenge.html">Challenge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <em>AuthMethod</em> and <em>Extra</em> dictionary contained within WAMP <code>CHALLENGE</code> messages.  <a href="classwamp_1_1_challenge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_connector.html">Connector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for establishing client transport endpoints.  <a href="classwamp_1_1_connector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_conversion_access.html">ConversionAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used to gain access to private conversion member functions.  <a href="classwamp_1_1_conversion_access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_coro_event_unpacker.html">CoroEventUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around an event coroutine slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_coro_event_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_coro_invocation_unpacker.html">CoroInvocationUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a call coroutine slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_coro_invocation_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_coro_session.html">CoroSession</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coroutine API used by a <em>client</em> peer in WAMP applications.  <a href="classwamp_1_1_coro_session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_decoding_category.html">DecodingCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::error_category used for reporting deserialization errors.  <a href="classwamp_1_1_decoding_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_deferment.html">Deferment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type that can be passed to <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation.">wamp::Outcome</a> to construct a deferred outcome.  <a href="structwamp_1_1_deferment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <em>reason</em> URI, options, and payload arguments contained within WAMP <code>ERROR</code> messages.  <a href="classwamp_1_1_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_error_or.html">ErrorOr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimalistic implementation of <a href="https://wg21.link/P0323">std::expected</a>&lt;T, std::error_code&gt;  <a href="classwamp_1_1_error_or.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_event.html">Event</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the subscription/publication ids, options, and payload contained within WAMP <code>EVENT</code> messages.  <a href="classwamp_1_1_event.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_event_unpacker.html">EventUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around an event slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_event_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a source <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>, used for conversions.  <a href="classwamp_1_1_from_variant_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_input_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_input_category">InputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_input_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that determines the category type that best matches the given input type.  <a href="namespacewamp.html#structwamp_1_1_input_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_input_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_interruption.html">Interruption</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains details within WAMP <code>INTERRUPT</code> messages.  <a href="classwamp_1_1_interruption.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_invocation.html">Invocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains payload arguments and other options within WAMP <code>INVOCATION</code> messages.  <a href="classwamp_1_1_invocation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_invocation_unpacker.html">InvocationUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a call slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_invocation_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_json.html">Json</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON format tag type.  <a href="structwamp_1_1_json.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_known_codec_ids.html">KnownCodecIds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs used by rawsocket transports to negotiate the serializer.  <a href="structwamp_1_1_known_codec_ids.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_msgpack.html">Msgpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> format tag type.  <a href="structwamp_1_1_msgpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_null.html">Null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to represent a null or empty <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> value.  <a href="structwamp_1_1_null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a WAMP message containing an options dictionary.  <a href="classwamp_1_1_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_outcome.html">Outcome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the outcome of an RPC invocation.  <a href="classwamp_1_1_outcome.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_output_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_output_category">OutputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_output_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class that determines the category type that best matches the given output type.  <a href="namespacewamp.html#structwamp_1_1_output_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_output_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_payload.html">Payload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a WAMP message containing payload arguments and an options dictionary.  <a href="classwamp_1_1_payload.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_procedure.html">Procedure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the procedure URI and other options contained within WAMP <code>REGISTER</code> messages.  <a href="classwamp_1_1_procedure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_protocol_category.html">ProtocolCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::error_category used for reporting protocol errors related to invalid WAMP messages.  <a href="classwamp_1_1_protocol_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_pub.html">Pub</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the topic URI, options, and payload contained within WAMP <code>PUBLISH</code> messages.  <a href="classwamp_1_1_pub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_rawsock_category.html">RawsockCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::error_category used for reporting errors specific to raw socket transports.  <a href="classwamp_1_1_rawsock_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_realm.html">Realm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realm URI and other options contained within WAMP <code>HELLO</code> messages.  <a href="classwamp_1_1_realm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_reason.html">Reason</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the <em>reason</em> URI and other options contained within <code>GOODBYE</code> messages.  <a href="classwamp_1_1_reason.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_registration.html">Registration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote procedure registration.  <a href="classwamp_1_1_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_result.html">Result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the remote procedure result options/payload within WAMP <code>RESULT</code> and <code>YIELD</code> messages.  <a href="classwamp_1_1_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_rpc.html">Rpc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the procedure URI, options, and payload contained within WAMP <code>CALL</code> messages.  <a href="classwamp_1_1_rpc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_scoped_registration.html">ScopedRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits a <a class="el" href="classwamp_1_1_registration.html" title="Represents a remote procedure registration.">Registration</a>'s lifetime to a particular scope.  <a href="classwamp_1_1_scoped_registration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_scoped_subscription.html">ScopedSubscription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limits a <a class="el" href="classwamp_1_1_subscription.html" title="Represents a pub/sub event subscription.">Subscription</a>'s lifetime to a particular scope.  <a href="classwamp_1_1_scoped_subscription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_session.html">Session</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session API used by a <em>client</em> peer in WAMP applications.  <a href="classwamp_1_1_session.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_session_category.html">SessionCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::error_category used for reporting errors at the WAMP session layer.  <a href="classwamp_1_1_session_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_session_info.html">SessionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwamp_1_1_session.html" title="Session API used by a client peer in WAMP applications.">Session</a> information contained within WAMP <code>WELCOME</code> messages.  <a href="classwamp_1_1_session_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html">SimpleCoroEventUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around an event slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_simple_coro_event_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html">SimpleCoroInvocationUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a call slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_simple_coro_invocation_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_simple_event_unpacker.html">SimpleEventUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around an event slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_simple_event_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_simple_invocation_unpacker.html">SimpleInvocationUnpacker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a call slot which automatically unpacks positional payload arguments.  <a href="classwamp_1_1_simple_invocation_unpacker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_stream_input_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_stream_input_category">StreamInputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_stream_input_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input category for input streams of bytes.  <a href="namespacewamp.html#structwamp_1_1_stream_input_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_stream_input_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_stream_output_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_stream_output_category">StreamOutputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_stream_output_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output category for output streams of bytes.  <a href="namespacewamp.html#structwamp_1_1_stream_output_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_stream_output_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_subscription.html">Subscription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pub/sub event subscription.  <a href="classwamp_1_1_subscription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_tcp_host.html">TcpHost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains TCP host address information, as well as other socket options.  <a href="classwamp_1_1_tcp_host.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_tcp_options.html">TcpOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains options for the TCP transport.  <a href="classwamp_1_1_tcp_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_thread_safe.html">ThreadSafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag type used to specify than an operation is to be dispatched via the called objects's execution strand.  <a href="structwamp_1_1_thread_safe.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_topic.html">Topic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the topic URI and other options contained within WAMP &lsquo;SUBSCRIBE&rsquo; messages.  <a href="classwamp_1_1_topic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a destination <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>, used for conversions.  <a href="classwamp_1_1_to_variant_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_transport_category.html">TransportCategory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::error_category used for reporting errors at the transport layer.  <a href="classwamp_1_1_transport_category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_uds_options.html">UdsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains options for the UNIX domain socket transport.  <a href="classwamp_1_1_uds_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_uds_path.html">UdsPath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a Unix domain socket path, as well as other socket options.  <a href="classwamp_1_1_uds_path.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_unexpected.html">Unexpected</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimalistic implementation of <a href="https://wg21.link/P0323#expected.un">std::unexpected</a>&lt;std::error_code&gt;.  <a href="classwamp_1_1_unexpected.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_unknown_input_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_unknown_input_category">UnknownInputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_unknown_input_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to indicate input category detection failed.  <a href="namespacewamp.html#structwamp_1_1_unknown_input_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_unknown_input_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structwamp_1_1_unknown_output_category"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#structwamp_1_1_unknown_output_category">UnknownOutputCategory</a></td></tr>
<tr class="memdesc:structwamp_1_1_unknown_output_category"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to indicate output category detection failed.  <a href="namespacewamp.html#structwamp_1_1_unknown_output_category">More...</a><br /></td></tr>
<tr class="separator:structwamp_1_1_unknown_output_category"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwamp_1_1_variant.html">Variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discriminated union container that represents a JSON value.  <a href="classwamp_1_1_variant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwamp_1_1_version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundles the major, minor, and patch version numbers.  <a href="structwamp_1_1_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classwamp_1_1_visitor"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#classwamp_1_1_visitor">Visitor</a></td></tr>
<tr class="memdesc:classwamp_1_1_visitor"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience base class used to meet the result type requirements of a <a class="el" href="_visitor_concept.html#StaticVisitor">StaticVisitor</a>.  <a href="namespacewamp.html#classwamp_1_1_visitor">More...</a><br /></td></tr>
<tr class="separator:classwamp_1_1_visitor"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa11625cd4da3b272d07186ecbfba2811"><td class="memItemLeft" align="right" valign="top"><a id="aa11625cd4da3b272d07186ecbfba2811"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa11625cd4da3b272d07186ecbfba2811">AnyCompletionExecutor</a> = boost::asio::any_completion_executor</td></tr>
<tr class="memdesc:aa11625cd4da3b272d07186ecbfba2811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erases an executor that is to be used with type-erased handlers. <br /></td></tr>
<tr class="separator:aa11625cd4da3b272d07186ecbfba2811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6509d647b5ebde3dfb56bef0e7fcea4"><td class="memTemplParams" colspan="2">template&lt;typename TSignature &gt; </td></tr>
<tr class="memitem:af6509d647b5ebde3dfb56bef0e7fcea4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#af6509d647b5ebde3dfb56bef0e7fcea4">AnyCompletionHandler</a> = boost::asio::any_completion_handler&lt; TSignature &gt;</td></tr>
<tr class="memdesc:af6509d647b5ebde3dfb56bef0e7fcea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erases a one-shot (and possibly move-only) asynchronous completion handler.  <a href="namespacewamp.html#af6509d647b5ebde3dfb56bef0e7fcea4">More...</a><br /></td></tr>
<tr class="separator:af6509d647b5ebde3dfb56bef0e7fcea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c1d3b5bec84434d0b3c472d2c3f93"><td class="memItemLeft" align="right" valign="top"><a id="a1a6c1d3b5bec84434d0b3c472d2c3f93"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a1a6c1d3b5bec84434d0b3c472d2c3f93">AnyIoExecutor</a> = boost::asio::any_io_executor</td></tr>
<tr class="memdesc:a1a6c1d3b5bec84434d0b3c472d2c3f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic executor for all I/O objects. <br /></td></tr>
<tr class="separator:a1a6c1d3b5bec84434d0b3c472d2c3f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09b74da0f1191be8b20ae04161c14c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ac09b74da0f1191be8b20ae04161c14c3">AnyExecutor</a> = <a class="el" href="namespacewamp.html#a1a6c1d3b5bec84434d0b3c472d2c3f93">AnyIoExecutor</a></td></tr>
<tr class="memdesc:ac09b74da0f1191be8b20ae04161c14c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of AnyIoExecutor kept for backward compatibility.  <a href="namespacewamp.html#ac09b74da0f1191be8b20ae04161c14c3">More...</a><br /></td></tr>
<tr class="separator:ac09b74da0f1191be8b20ae04161c14c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd954da85bf9033739185b3a29e3e85"><td class="memItemLeft" align="right" valign="top"><a id="a9dd954da85bf9033739185b3a29e3e85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9dd954da85bf9033739185b3a29e3e85">AsioContext</a> = boost::asio::io_context</td></tr>
<tr class="memdesc:a9dd954da85bf9033739185b3a29e3e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues and runs I/O completion handlers. <br /></td></tr>
<tr class="separator:a9dd954da85bf9033739185b3a29e3e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24590d6853d0156e07654228b3b1db7e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a24590d6853d0156e07654228b3b1db7e">AsioService</a> = <a class="el" href="namespacewamp.html#a9dd954da85bf9033739185b3a29e3e85">AsioContext</a></td></tr>
<tr class="memdesc:a24590d6853d0156e07654228b3b1db7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of AsioContext kept for backward compatibility.  <a href="namespacewamp.html#a24590d6853d0156e07654228b3b1db7e">More...</a><br /></td></tr>
<tr class="separator:a24590d6853d0156e07654228b3b1db7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb99c75b9a03f6987cac708c17c32bb"><td class="memItemLeft" align="right" valign="top"><a id="abdb99c75b9a03f6987cac708c17c32bb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#abdb99c75b9a03f6987cac708c17c32bb">IoStrand</a> = boost::asio::strand&lt; <a class="el" href="namespacewamp.html#a1a6c1d3b5bec84434d0b3c472d2c3f93">AnyIoExecutor</a> &gt;</td></tr>
<tr class="memdesc:abdb99c75b9a03f6987cac708c17c32bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes I/O operations. <br /></td></tr>
<tr class="separator:abdb99c75b9a03f6987cac708c17c32bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb149f6fd1f5f5508fcf1f90f01381b"><td class="memItemLeft" align="right" valign="top"><a id="adeb149f6fd1f5f5508fcf1f90f01381b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#adeb149f6fd1f5f5508fcf1f90f01381b">AsioErrorCode</a> = boost::system::error_code</td></tr>
<tr class="memdesc:adeb149f6fd1f5f5508fcf1f90f01381b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used by Boost.Asio for reporting errors. <br /></td></tr>
<tr class="separator:adeb149f6fd1f5f5508fcf1f90f01381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9cb853e7659f333d612681d98d4e11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c9cb853e7659f333d612681d98d4e11"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a7c9cb853e7659f333d612681d98d4e11">AsyncResult</a> = <a class="el" href="classwamp_1_1_error_or.html">ErrorOr</a>&lt; T &gt;</td></tr>
<tr class="separator:a7c9cb853e7659f333d612681d98d4e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5583bd8b9f3abe95175e5079ec078"><td class="memItemLeft" align="right" valign="top"><a id="ac1b5583bd8b9f3abe95175e5079ec078"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ac1b5583bd8b9f3abe95175e5079ec078">CborStringEncoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_encoder.html">BasicCborEncoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:ac1b5583bd8b9f3abe95175e5079ec078"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR encoder type that encodes into a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:ac1b5583bd8b9f3abe95175e5079ec078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6467427850cda7c4f3ad481e767aa1"><td class="memItemLeft" align="right" valign="top"><a id="aac6467427850cda7c4f3ad481e767aa1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aac6467427850cda7c4f3ad481e767aa1">CborBufferEncoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_encoder.html">BasicCborEncoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:aac6467427850cda7c4f3ad481e767aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR encoder type that encodes into a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:aac6467427850cda7c4f3ad481e767aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1c093405721f07373af5f966bf7998"><td class="memItemLeft" align="right" valign="top"><a id="a1c1c093405721f07373af5f966bf7998"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a1c1c093405721f07373af5f966bf7998">CborStreamEncoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_encoder.html">BasicCborEncoder</a>&lt; std::ostream &gt;</td></tr>
<tr class="memdesc:a1c1c093405721f07373af5f966bf7998"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR encoder type that encodes into a std::ostream. *&zwj;/. <br /></td></tr>
<tr class="separator:a1c1c093405721f07373af5f966bf7998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5aafdb00663bb9cfc76f0c43cc51bc"><td class="memItemLeft" align="right" valign="top"><a id="aca5aafdb00663bb9cfc76f0c43cc51bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aca5aafdb00663bb9cfc76f0c43cc51bc">CborStringDecoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_decoder.html">BasicCborDecoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:aca5aafdb00663bb9cfc76f0c43cc51bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR decoder type that decodes from a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:aca5aafdb00663bb9cfc76f0c43cc51bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebda4c8c539de611385aaa6bd1351537"><td class="memItemLeft" align="right" valign="top"><a id="aebda4c8c539de611385aaa6bd1351537"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aebda4c8c539de611385aaa6bd1351537">CborBufferDecoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_decoder.html">BasicCborDecoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:aebda4c8c539de611385aaa6bd1351537"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR decoder type that decodes from a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:aebda4c8c539de611385aaa6bd1351537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5383b1a064d8bb9211ec76d9e729a4dc"><td class="memItemLeft" align="right" valign="top"><a id="a5383b1a064d8bb9211ec76d9e729a4dc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a5383b1a064d8bb9211ec76d9e729a4dc">CborStreamDecoder</a> = <a class="el" href="classwamp_1_1_basic_cbor_decoder.html">BasicCborDecoder</a>&lt; std::istream &gt;</td></tr>
<tr class="memdesc:a5383b1a064d8bb9211ec76d9e729a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">CBOR decoder type that decodes from a std::istream. *&zwj;/. <br /></td></tr>
<tr class="separator:a5383b1a064d8bb9211ec76d9e729a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23304b303f41e1c59990dd5a8623615"><td class="memTemplParams" colspan="2"><a id="ac23304b303f41e1c59990dd5a8623615"></a>
template&lt;typename O &gt; </td></tr>
<tr class="memitem:ac23304b303f41e1c59990dd5a8623615"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ac23304b303f41e1c59990dd5a8623615">OutputCategoryTypeOf</a> = typename <a class="el" href="namespacewamp.html#structwamp_1_1_output_category">OutputCategory</a>&lt; <a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt; O &gt; &gt;::type</td></tr>
<tr class="memdesc:ac23304b303f41e1c59990dd5a8623615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the category type that best matches the given output type. <br /></td></tr>
<tr class="separator:ac23304b303f41e1c59990dd5a8623615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4f63f74b0ede851c60223ecf3674e5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename O , typename C  = OutputCategoryTypeOf&lt;O&gt;&gt; </td></tr>
<tr class="memitem:a3a4f63f74b0ede851c60223ecf3674e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5">Encoder</a> = typename F::template <a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5">Encoder</a>&lt; <a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt; O &gt;, C &gt;</td></tr>
<tr class="memdesc:a3a4f63f74b0ede851c60223ecf3674e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the encoder type needed to encode a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> to the given output type and output category.  <a href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5">More...</a><br /></td></tr>
<tr class="separator:a3a4f63f74b0ede851c60223ecf3674e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f560dce7bd9330d1f08570a6b9cd250"><td class="memTemplParams" colspan="2"><a id="a8f560dce7bd9330d1f08570a6b9cd250"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:a8f560dce7bd9330d1f08570a6b9cd250"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a8f560dce7bd9330d1f08570a6b9cd250">InputCategoryTypeOf</a> = typename <a class="el" href="namespacewamp.html#structwamp_1_1_input_category">InputCategory</a>&lt; <a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt; I &gt; &gt;::type</td></tr>
<tr class="memdesc:a8f560dce7bd9330d1f08570a6b9cd250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the category type that best matches the given input type. <br /></td></tr>
<tr class="separator:a8f560dce7bd9330d1f08570a6b9cd250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612977014a4cf2e1d8f58406b95d0e6e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename I , typename C  = InputCategoryTypeOf&lt;I&gt;&gt; </td></tr>
<tr class="memitem:a612977014a4cf2e1d8f58406b95d0e6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e">Decoder</a> = typename F::template <a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e">Decoder</a>&lt; <a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt; I &gt;, C &gt;</td></tr>
<tr class="memdesc:a612977014a4cf2e1d8f58406b95d0e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the decoder type needed to decode a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> from the given input type and input category.  <a href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e">More...</a><br /></td></tr>
<tr class="separator:a612977014a4cf2e1d8f58406b95d0e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e518db13376e7a5f5cf73a3c5d2414"><td class="memItemLeft" align="right" valign="top"><a id="af5e518db13376e7a5f5cf73a3c5d2414"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#af5e518db13376e7a5f5cf73a3c5d2414">ConnectorList</a> = std::vector&lt; <a class="el" href="classwamp_1_1_connector.html#a71ed161f97ca2300f2e97e8ce9ab211b">Connector::Ptr</a> &gt;</td></tr>
<tr class="memdesc:af5e518db13376e7a5f5cf73a3c5d2414"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of <a class="el" href="classwamp_1_1_connector.html" title="Abstract base class for establishing client transport endpoints.">Connector</a> objects to use when attempting connection. <br /></td></tr>
<tr class="separator:af5e518db13376e7a5f5cf73a3c5d2414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f634581655053f937d8d405a6126c9"><td class="memTemplParams" colspan="2">template&lt;typename TSlot , typename... TArgs&gt; </td></tr>
<tr class="memitem:a60f634581655053f937d8d405a6126c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a60f634581655053f937d8d405a6126c9">BasicCoroEventUnpacker</a> = <a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html">SimpleCoroEventUnpacker</a>&lt; TSlot, TArgs... &gt;</td></tr>
<tr class="memdesc:a60f634581655053f937d8d405a6126c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleCoroEventUnpacker</a> kept for backward compatibility.  <a href="namespacewamp.html#a60f634581655053f937d8d405a6126c9">More...</a><br /></td></tr>
<tr class="separator:a60f634581655053f937d8d405a6126c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c048c8cb747c215876982c8b2f7b394"><td class="memTemplParams" colspan="2">template&lt;typename TSlot , typename TResult , typename... TArgs&gt; </td></tr>
<tr class="memitem:a3c048c8cb747c215876982c8b2f7b394"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3c048c8cb747c215876982c8b2f7b394">BasicCoroInvocationUnpacker</a> = <a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html">SimpleCoroInvocationUnpacker</a>&lt; TSlot, TResult, TArgs... &gt;</td></tr>
<tr class="memdesc:a3c048c8cb747c215876982c8b2f7b394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleCoroInvocationUnpacker</a> kept for backward compability.  <a href="namespacewamp.html#a3c048c8cb747c215876982c8b2f7b394">More...</a><br /></td></tr>
<tr class="separator:a3c048c8cb747c215876982c8b2f7b394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4069b3fda38bf2051619ad71bc76e7b"><td class="memItemLeft" align="right" valign="top"><a id="ac4069b3fda38bf2051619ad71bc76e7b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ac4069b3fda38bf2051619ad71bc76e7b">UnexpectedError</a> = <a class="el" href="classwamp_1_1_unexpected.html">Unexpected</a>&lt; std::error_code &gt;</td></tr>
<tr class="memdesc:ac4069b3fda38bf2051619ad71bc76e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for Unexpected&lt;std::error_code&gt;. <br /></td></tr>
<tr class="separator:ac4069b3fda38bf2051619ad71bc76e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c09a2f6e3421b60dc5b56b9d933d62b"><td class="memTemplParams" colspan="2"><a id="a0c09a2f6e3421b60dc5b56b9d933d62b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c09a2f6e3421b60dc5b56b9d933d62b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a0c09a2f6e3421b60dc5b56b9d933d62b">AsyncHandler</a> = std::function&lt; void(<a class="el" href="classwamp_1_1_error_or.html">ErrorOr</a>&lt; T &gt;)&gt;</td></tr>
<tr class="memdesc:a0c09a2f6e3421b60dc5b56b9d933d62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for a handler taking an <code><a class="el" href="classwamp_1_1_error_or.html" title="Minimalistic implementation of std::expected&lt;T, std::error_code&gt;">ErrorOr</a>&lt;T&gt;</code> parameter. <br /></td></tr>
<tr class="separator:a0c09a2f6e3421b60dc5b56b9d933d62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1944d19e89104ce892a074c5c1be43fb"><td class="memItemLeft" align="right" valign="top"><a id="a1944d19e89104ce892a074c5c1be43fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a1944d19e89104ce892a074c5c1be43fb">JsonStringEncoder</a> = <a class="el" href="classwamp_1_1_basic_json_encoder.html">BasicJsonEncoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:a1944d19e89104ce892a074c5c1be43fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON encoder type that encodes into a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:a1944d19e89104ce892a074c5c1be43fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae87067e4d1504cdb253e5ebde9db11d"><td class="memItemLeft" align="right" valign="top"><a id="aae87067e4d1504cdb253e5ebde9db11d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aae87067e4d1504cdb253e5ebde9db11d">JsonBufferEncoder</a> = <a class="el" href="classwamp_1_1_basic_json_encoder.html">BasicJsonEncoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:aae87067e4d1504cdb253e5ebde9db11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON encoder type that encodes into a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:aae87067e4d1504cdb253e5ebde9db11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f8ab0888942961c83fa7985e08b552"><td class="memItemLeft" align="right" valign="top"><a id="ab2f8ab0888942961c83fa7985e08b552"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ab2f8ab0888942961c83fa7985e08b552">JsonStreamEncoder</a> = <a class="el" href="classwamp_1_1_basic_json_encoder.html">BasicJsonEncoder</a>&lt; std::ostream &gt;</td></tr>
<tr class="memdesc:ab2f8ab0888942961c83fa7985e08b552"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON encoder type that encodes into a std::ostream. *&zwj;/. <br /></td></tr>
<tr class="separator:ab2f8ab0888942961c83fa7985e08b552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb8b62e9fc425b7fa395c9fa26c31c6"><td class="memItemLeft" align="right" valign="top"><a id="aefb8b62e9fc425b7fa395c9fa26c31c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aefb8b62e9fc425b7fa395c9fa26c31c6">JsonStringDecoder</a> = <a class="el" href="classwamp_1_1_basic_json_decoder.html">BasicJsonDecoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:aefb8b62e9fc425b7fa395c9fa26c31c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON decoder type that decodes from a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:aefb8b62e9fc425b7fa395c9fa26c31c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e0b8986fb00c97df1f6c68bb9673dd"><td class="memItemLeft" align="right" valign="top"><a id="a71e0b8986fb00c97df1f6c68bb9673dd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a71e0b8986fb00c97df1f6c68bb9673dd">JsonBufferDecoder</a> = <a class="el" href="classwamp_1_1_basic_json_decoder.html">BasicJsonDecoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:a71e0b8986fb00c97df1f6c68bb9673dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON decoder type that decodes from a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:a71e0b8986fb00c97df1f6c68bb9673dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30876bd8c93f726ffc1d02fe0aacdcf7"><td class="memItemLeft" align="right" valign="top"><a id="a30876bd8c93f726ffc1d02fe0aacdcf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a30876bd8c93f726ffc1d02fe0aacdcf7">JsonStreamDecoder</a> = <a class="el" href="classwamp_1_1_basic_json_decoder.html">BasicJsonDecoder</a>&lt; std::istream &gt;</td></tr>
<tr class="memdesc:a30876bd8c93f726ffc1d02fe0aacdcf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSON decoder type that decodes from a std::ostream. *&zwj;/. <br /></td></tr>
<tr class="separator:a30876bd8c93f726ffc1d02fe0aacdcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a816c28c390a5b511d6343d0b009ded"><td class="memItemLeft" align="right" valign="top"><a id="a1a816c28c390a5b511d6343d0b009ded"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> = std::vector&lt; uint8_t &gt;</td></tr>
<tr class="memdesc:a1a816c28c390a5b511d6343d0b009ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container type used for encoded WAMP messages that are sent/received over a transport. <br /></td></tr>
<tr class="separator:a1a816c28c390a5b511d6343d0b009ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2418c2c88b10c1601524492e54e92990"><td class="memItemLeft" align="right" valign="top"><a id="a2418c2c88b10c1601524492e54e92990"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a2418c2c88b10c1601524492e54e92990">MsgpackStringEncoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_encoder.html">BasicMsgpackEncoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:a2418c2c88b10c1601524492e54e92990"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> encoder type that encodes into a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:a2418c2c88b10c1601524492e54e92990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e50658fd918a917e399a5cebbaf42f2"><td class="memItemLeft" align="right" valign="top"><a id="a7e50658fd918a917e399a5cebbaf42f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a7e50658fd918a917e399a5cebbaf42f2">MsgpackBufferEncoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_encoder.html">BasicMsgpackEncoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:a7e50658fd918a917e399a5cebbaf42f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> encoder type that encodes into a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:a7e50658fd918a917e399a5cebbaf42f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffb05fdaee1766025e453e3e14312d7"><td class="memItemLeft" align="right" valign="top"><a id="a5ffb05fdaee1766025e453e3e14312d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a5ffb05fdaee1766025e453e3e14312d7">MsgpackStreamEncoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_encoder.html">BasicMsgpackEncoder</a>&lt; std::ostream &gt;</td></tr>
<tr class="memdesc:a5ffb05fdaee1766025e453e3e14312d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> encoder type that encodes into a std::ostream. *&zwj;/. <br /></td></tr>
<tr class="separator:a5ffb05fdaee1766025e453e3e14312d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9ee6ec24ea0667587ebbd249e293a0"><td class="memItemLeft" align="right" valign="top"><a id="a3f9ee6ec24ea0667587ebbd249e293a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3f9ee6ec24ea0667587ebbd249e293a0">MsgpackStringDecoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_decoder.html">BasicMsgpackDecoder</a>&lt; std::string &gt;</td></tr>
<tr class="memdesc:a3f9ee6ec24ea0667587ebbd249e293a0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> decoder type that decodes from a std::string. *&zwj;/. <br /></td></tr>
<tr class="separator:a3f9ee6ec24ea0667587ebbd249e293a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74685b6d5c6cec531dd60dd5aef04b01"><td class="memItemLeft" align="right" valign="top"><a id="a74685b6d5c6cec531dd60dd5aef04b01"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a74685b6d5c6cec531dd60dd5aef04b01">MsgpackBufferDecoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_decoder.html">BasicMsgpackDecoder</a>&lt; <a class="el" href="namespacewamp.html#a1a816c28c390a5b511d6343d0b009ded">MessageBuffer</a> &gt;</td></tr>
<tr class="memdesc:a74685b6d5c6cec531dd60dd5aef04b01"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> decoder type that decodes from a MessageBuffer. *&zwj;/. <br /></td></tr>
<tr class="separator:a74685b6d5c6cec531dd60dd5aef04b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a2e2b3847fef3b32c4fc8575a22441"><td class="memItemLeft" align="right" valign="top"><a id="ae5a2e2b3847fef3b32c4fc8575a22441"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ae5a2e2b3847fef3b32c4fc8575a22441">MsgpackStreamDecoder</a> = <a class="el" href="classwamp_1_1_basic_msgpack_decoder.html">BasicMsgpackDecoder</a>&lt; std::istream &gt;</td></tr>
<tr class="memdesc:ae5a2e2b3847fef3b32c4fc8575a22441"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structwamp_1_1_msgpack.html" title="Msgpack format tag type.">Msgpack</a> decoder type that decodes from a std::ostream. *&zwj;/. <br /></td></tr>
<tr class="separator:ae5a2e2b3847fef3b32c4fc8575a22441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22abefe77bf3705196e2e756a0c134b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a22abefe77bf3705196e2e756a0c134b8">Cancellation</a> = <a class="el" href="classwamp_1_1_call_cancellation.html">CallCancellation</a></td></tr>
<tr class="memdesc:a22abefe77bf3705196e2e756a0c134b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="classwamp_1_1_call_cancellation.html" title="Contains the request ID and options contained within WAMP CANCEL messages.">CallCancellation</a> kept for backward compatiblity.  <a href="namespacewamp.html#a22abefe77bf3705196e2e756a0c134b8">More...</a><br /></td></tr>
<tr class="separator:a22abefe77bf3705196e2e756a0c134b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9806878793b2cdf53fe3a516b1a5bd69"><td class="memTemplParams" colspan="2"><a id="a9806878793b2cdf53fe3a516b1a5bd69"></a>
template&lt;bool B, typename T  = int&gt; </td></tr>
<tr class="memitem:a9806878793b2cdf53fe3a516b1a5bd69"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9806878793b2cdf53fe3a516b1a5bd69">EnableIf</a> = typename std::enable_if&lt; B, T &gt;::type</td></tr>
<tr class="memdesc:a9806878793b2cdf53fe3a516b1a5bd69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction used to enable overloads based on a boolean condition. <br /></td></tr>
<tr class="separator:a9806878793b2cdf53fe3a516b1a5bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688d950a7ec8a556ba83856a000b888"><td class="memTemplParams" colspan="2"><a id="a3688d950a7ec8a556ba83856a000b888"></a>
template&lt;bool B, typename T  = int&gt; </td></tr>
<tr class="memitem:a3688d950a7ec8a556ba83856a000b888"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3688d950a7ec8a556ba83856a000b888">DisableIf</a> = typename std::enable_if&lt;!B, T &gt;::type</td></tr>
<tr class="memdesc:a3688d950a7ec8a556ba83856a000b888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction used to disable overloads based on a boolean condition. <br /></td></tr>
<tr class="separator:a3688d950a7ec8a556ba83856a000b888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe046bb975ae7fe4ddccc4e4e234a1d"><td class="memTemplParams" colspan="2"><a id="aefe046bb975ae7fe4ddccc4e4e234a1d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefe046bb975ae7fe4ddccc4e4e234a1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a> = typename std::remove_cv&lt; typename std::remove_reference&lt; T &gt;::type &gt;::type</td></tr>
<tr class="memdesc:aefe046bb975ae7fe4ddccc4e4e234a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction used to obtain the plain value type of a parameter passed by universal reference. <br /></td></tr>
<tr class="separator:aefe046bb975ae7fe4ddccc4e4e234a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4fabd4c0140f8ca90aa6104ffa1f0"><td class="memTemplParams" colspan="2"><a id="afac4fabd4c0140f8ca90aa6104ffa1f0"></a>
template&lt;int N, typename... Ts&gt; </td></tr>
<tr class="memitem:afac4fabd4c0140f8ca90aa6104ffa1f0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#afac4fabd4c0140f8ca90aa6104ffa1f0">NthTypeOf</a> = typename std::tuple_element&lt; N, std::tuple&lt; Ts... &gt; &gt;::type</td></tr>
<tr class="memdesc:afac4fabd4c0140f8ca90aa6104ffa1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction that obtains the Nth type of a parameter pack. <br /></td></tr>
<tr class="separator:afac4fabd4c0140f8ca90aa6104ffa1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8480b59e7afcb4b544ade9f3361c5c"><td class="memTemplParams" colspan="2"><a id="a7b8480b59e7afcb4b544ade9f3361c5c"></a>
template&lt;bool B&gt; </td></tr>
<tr class="memitem:a7b8480b59e7afcb4b544ade9f3361c5c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a7b8480b59e7afcb4b544ade9f3361c5c">BoolConstant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:a7b8480b59e7afcb4b544ade9f3361c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to std::bool_constant provided in C++17. <br /></td></tr>
<tr class="separator:a7b8480b59e7afcb4b544ade9f3361c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79912569893dfb927f34a7796080f25"><td class="memItemLeft" align="right" valign="top"><a id="af79912569893dfb927f34a7796080f25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#af79912569893dfb927f34a7796080f25">TrueType</a> = <a class="el" href="namespacewamp.html#a7b8480b59e7afcb4b544ade9f3361c5c">BoolConstant</a>&lt; true &gt;</td></tr>
<tr class="memdesc:af79912569893dfb927f34a7796080f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to std::true_type provided in C++17. <br /></td></tr>
<tr class="separator:af79912569893dfb927f34a7796080f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4120fd9401fc349960e8ff7f72fb14"><td class="memItemLeft" align="right" valign="top"><a id="adb4120fd9401fc349960e8ff7f72fb14"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#adb4120fd9401fc349960e8ff7f72fb14">FalseType</a> = <a class="el" href="namespacewamp.html#a7b8480b59e7afcb4b544ade9f3361c5c">BoolConstant</a>&lt; false &gt;</td></tr>
<tr class="memdesc:adb4120fd9401fc349960e8ff7f72fb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to std::false_type provided in C++17. <br /></td></tr>
<tr class="separator:adb4120fd9401fc349960e8ff7f72fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb68057439fa3d32bb02ac8d707206fc"><td class="memTemplParams" colspan="2"><a id="afb68057439fa3d32bb02ac8d707206fc"></a>
template&lt;typename TSlot &gt; </td></tr>
<tr class="memitem:afb68057439fa3d32bb02ac8d707206fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a> = typename std::decay&lt; TSlot &gt;::type</td></tr>
<tr class="memdesc:afb68057439fa3d32bb02ac8d707206fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction that removes const/reference decorations off a slot type. <br /></td></tr>
<tr class="separator:afb68057439fa3d32bb02ac8d707206fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba148e03444eba9aa3d9c0f770883d5"><td class="memTemplParams" colspan="2">template&lt;typename TSlot , typename... TArgs&gt; </td></tr>
<tr class="memitem:a3ba148e03444eba9aa3d9c0f770883d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3ba148e03444eba9aa3d9c0f770883d5">BasicEventUnpacker</a> = <a class="el" href="classwamp_1_1_simple_event_unpacker.html">SimpleEventUnpacker</a>&lt; TSlot, TArgs... &gt;</td></tr>
<tr class="memdesc:a3ba148e03444eba9aa3d9c0f770883d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="classwamp_1_1_simple_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleEventUnpacker</a> kept for backward compatiblity.  <a href="namespacewamp.html#a3ba148e03444eba9aa3d9c0f770883d5">More...</a><br /></td></tr>
<tr class="separator:a3ba148e03444eba9aa3d9c0f770883d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa434cc11de6a09adcf68f1e25258e980"><td class="memTemplParams" colspan="2">template&lt;typename TSlot , typename TResult , typename... TArgs&gt; </td></tr>
<tr class="memitem:aa434cc11de6a09adcf68f1e25258e980"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa434cc11de6a09adcf68f1e25258e980">BasicInvocationUnpacker</a> = <a class="el" href="classwamp_1_1_simple_invocation_unpacker.html">SimpleInvocationUnpacker</a>&lt; TSlot, TResult, TArgs... &gt;</td></tr>
<tr class="memdesc:aa434cc11de6a09adcf68f1e25258e980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to <a class="el" href="classwamp_1_1_simple_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleInvocationUnpacker</a> kept for backward compability.  <a href="namespacewamp.html#aa434cc11de6a09adcf68f1e25258e980">More...</a><br /></td></tr>
<tr class="separator:aa434cc11de6a09adcf68f1e25258e980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8949d385f548e570ad954089b7439dc1"><td class="memItemLeft" align="right" valign="top"><a id="a8949d385f548e570ad954089b7439dc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a8949d385f548e570ad954089b7439dc1">SessionId</a> = int64_t</td></tr>
<tr class="memdesc:a8949d385f548e570ad954089b7439dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ephemeral ID associated with a WAMP session. <br /></td></tr>
<tr class="separator:a8949d385f548e570ad954089b7439dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69525a134cfe3de73c79af0e80f2ff2"><td class="memItemLeft" align="right" valign="top"><a id="ad69525a134cfe3de73c79af0e80f2ff2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ad69525a134cfe3de73c79af0e80f2ff2">RequestId</a> = int64_t</td></tr>
<tr class="memdesc:ad69525a134cfe3de73c79af0e80f2ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ephemeral ID associated with a WAMP request. <br /></td></tr>
<tr class="separator:ad69525a134cfe3de73c79af0e80f2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15249f3ad90f2f5fa5d30317c84fbce8"><td class="memItemLeft" align="right" valign="top"><a id="a15249f3ad90f2f5fa5d30317c84fbce8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a15249f3ad90f2f5fa5d30317c84fbce8">SubscriptionId</a> = int64_t</td></tr>
<tr class="memdesc:a15249f3ad90f2f5fa5d30317c84fbce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ephemeral ID associated with an topic subscription. <br /></td></tr>
<tr class="separator:a15249f3ad90f2f5fa5d30317c84fbce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1108039d1eea74def74485afcd801d5"><td class="memItemLeft" align="right" valign="top"><a id="af1108039d1eea74def74485afcd801d5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#af1108039d1eea74def74485afcd801d5">PublicationId</a> = int64_t</td></tr>
<tr class="memdesc:af1108039d1eea74def74485afcd801d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ephemeral ID associated with an event publication. <br /></td></tr>
<tr class="separator:af1108039d1eea74def74485afcd801d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a11e7b619d74f499adf34837731877b"><td class="memItemLeft" align="right" valign="top"><a id="a2a11e7b619d74f499adf34837731877b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a2a11e7b619d74f499adf34837731877b">RegistrationId</a> = int64_t</td></tr>
<tr class="memdesc:a2a11e7b619d74f499adf34837731877b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the value representing a blank RequestId. <br /></td></tr>
<tr class="separator:a2a11e7b619d74f499adf34837731877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6569c4e9bd084777aea6cf8ee0fea6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aec6569c4e9bd084777aea6cf8ee0fea6">CancelMode</a> = <a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">CallCancelMode</a></td></tr>
<tr class="memdesc:aec6569c4e9bd084777aea6cf8ee0fea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to CallCancelMode kept for backward compatibility.  <a href="namespacewamp.html#aec6569c4e9bd084777aea6cf8ee0fea6">More...</a><br /></td></tr>
<tr class="separator:aec6569c4e9bd084777aea6cf8ee0fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9ecf2a0b15a4d67bb0cd1928b4056d46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">SessionErrc</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a260ca9dd8a4577fc00b7bd5810298076">SessionErrc::success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a6398ee39c528ff4737ae63947d85d0a4">SessionErrc::sessionEnded</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a31d993ba59164643e0e2159e32b63216">SessionErrc::sessionEndedByPeer</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ae55e2d2dad2f8cb947d320333e4fd018">SessionErrc::allTransportsFailed</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46aa75d537e41b81dbfe97193fbc3c1a31c">SessionErrc::joinError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a829ceab85261d613afb28a51c65891fc">SessionErrc::publishError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a696e8572fae9cf279b6ae706bb198067">SessionErrc::subscribeError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a0af961c159db3c2e12ecefdcdd067f5d">SessionErrc::unsubscribeError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a5df9f1bf5e3db9c58bf704975f5b910b">SessionErrc::registerError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a46b3700b2b31b8385fe1d8ee86467afd">SessionErrc::unregisterError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46aef60a5ac24513b778c5cbf1c19849ade">SessionErrc::callError</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a34cbbc3e440497e007985a72c5ba90e0">SessionErrc::invalidState</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a2bea66a21ec3d2c8e0f5e53525b8ef7d">SessionErrc::invalidUri</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a2be9ffd8006ede69e1a0d3e504095d14">SessionErrc::noSuchProcedure</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a357062fb324f21ba4ec07cdc0af68164">SessionErrc::procedureAlreadyExists</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ac76490ae5599680eded015233639c5d2">SessionErrc::noSuchRegistration</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ac2887dee431a49d9f0ae352716e50de6">SessionErrc::noSuchSubscription</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ac37ace0e876e37d499a382934104b9eb">SessionErrc::invalidArgument</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a4e0fa97322f86ae1189c874d9627e843">SessionErrc::systemShutdown</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a99e3020a29f7fdcf1d466029c15f96db">SessionErrc::closeRealm</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a9c34b6023aecaad53774bb3c621510d7">SessionErrc::goodbyeAndOut</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46afd6ddc515a5476fed223435c88a937b1">SessionErrc::notAuthorized</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a23326a67dfb49576ae6d7f0ed9d124eb">SessionErrc::authorizationFailed</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a1f7f92026f85b91bf2c50b57390b12a6">SessionErrc::noSuchRealm</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ae36499a907b854bc2d653d1a28d48490">SessionErrc::noSuchRole</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a38881e0a24039dc2621e1d6f86cb71f7">SessionErrc::cancelled</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46a1de736abaefb5aee04f3c4e04a6fa221">SessionErrc::optionNotAllowed</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46ae8dbf1dde2318304f49bb205815f7fcd">SessionErrc::noEligibleCallee</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46afcceb3a3542cd0fdf32c652a1ea05395">SessionErrc::discloseMeDisallowed</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46af77654d8b67758cba023bfc9de1464b4">SessionErrc::networkFailure</a>
<br />
 }</td></tr>
<tr class="memdesc:a9ecf2a0b15a4d67bb0cd1928b4056d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code values used with the SessionCategory error category.  <a href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">More...</a><br /></td></tr>
<tr class="separator:a9ecf2a0b15a4d67bb0cd1928b4056d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6780fafb8e86182dabb1d5eddc9cc784"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784">DecodingErrc</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784a260ca9dd8a4577fc00b7bd5810298076">DecodingErrc::success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784a3ee28fe1a60c95b89d29317f122c7021">DecodingErrc::failure</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784a6ed8ac20ecdf679c91e80432006ee832">DecodingErrc::emptyInput</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784aefb00f8fd8f4a6c2018e90e91a891853">DecodingErrc::expectedStringKey</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784aff853bf855be9fdb7dbfa594e945e89b">DecodingErrc::badBase64Length</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784aec7221812154d114d010d55f855767bc">DecodingErrc::badBase64Padding</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784a962217c287faa972012b3142bd7d841c">DecodingErrc::badBase64Char</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a6780fafb8e86182dabb1d5eddc9cc784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code values used with the DecodingCategory error category.  <a href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784">More...</a><br /></td></tr>
<tr class="separator:a6780fafb8e86182dabb1d5eddc9cc784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ce4bc9c1e5512cec6ba323c4d324d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0">ProtocolErrc</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0a260ca9dd8a4577fc00b7bd5810298076">ProtocolErrc::success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0ad964fd778dc00a01e79c21066e53a6fe">ProtocolErrc::badDecode</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0a3b2142dd13569c21d672bb57b522b590">ProtocolErrc::badSchema</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0af44cec05923311221b1a36fc299fc124">ProtocolErrc::unsupportedMsg</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0a310cdeee6d2ef9c459c211b39a06d465">ProtocolErrc::unexpectedMsg</a>
<br />
 }</td></tr>
<tr class="memdesc:a19ce4bc9c1e5512cec6ba323c4d324d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code values used with the ProtocolCategory error category.  <a href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0">More...</a><br /></td></tr>
<tr class="separator:a19ce4bc9c1e5512cec6ba323c4d324d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a09562b29d4b6e42e37be77ec31829a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829a">TransportErrc</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829aa260ca9dd8a4577fc00b7bd5810298076">TransportErrc::success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829aadfb7069bfc6e0064a6c667626eca07b4">TransportErrc::aborted</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829aa26934eb377001f66e37289a5c93fe284">TransportErrc::failed</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829aab9c1fb72d859b4927608fb262096783a">TransportErrc::badTxLength</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829aa0e4488fc267b2d8dad253ab78f5b9e8c">TransportErrc::badRxLength</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a7a09562b29d4b6e42e37be77ec31829a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code values used with the TransportCategory error category.  <a href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829a">More...</a><br /></td></tr>
<tr class="separator:a7a09562b29d4b6e42e37be77ec31829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bf722cbe7ad04d49ad94b6ec440541"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541">RawsockErrc</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541a260ca9dd8a4577fc00b7bd5810298076">RawsockErrc::success</a> = 0, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541aa5e02f2492945f6f4616d60c7bf0f441">RawsockErrc::badSerializer</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541acc60048c7f1cfedb42fb691a65560754">RawsockErrc::badMaxLength</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541abb289e45a93481a3f9d352d606b24a52">RawsockErrc::reservedBitsUsed</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541a8e5cd4823b78ba1dbe5615f8a72cc451">RawsockErrc::maxConnectionsReached</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541af55842d15f31953fa4b495f84937ab40">RawsockErrc::badHandshake</a> = 16, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541a9a41b8fb027b252366984a29cb58423b">RawsockErrc::badMessageType</a> = 17
<br />
 }</td></tr>
<tr class="memdesc:aa0bf722cbe7ad04d49ad94b6ec440541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error code values used with the RawsockCategory error category.  <a href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541">More...</a><br /></td></tr>
<tr class="separator:aa0bf722cbe7ad04d49ad94b6ec440541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1750e952cec62e645c6b1c918c06993f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993f">RawsockMaxLength</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa23ccc75192d274e4baa1390df758b7a9">RawsockMaxLength::B_512</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa95820889c57ed2e14f37a3d40b04d3eb">RawsockMaxLength::kB_1</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993faedc30900c1b9071feb2b244109a8c25b">RawsockMaxLength::kB_2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa8383e4e8f8e6f97da2665c52a0b31440">RawsockMaxLength::kB_4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa0df6f473c642920931b17d3866531994">RawsockMaxLength::kB_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa23606eba3869aa06ec21f65a6af4f9f9">RawsockMaxLength::kB_16</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa8ac627000912010efd3beece803acb81">RawsockMaxLength::kB_32</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fad79bc0f95213a9b2d654ac146dff2811">RawsockMaxLength::kB_64</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa186d40edc766c000a01178d48d5cbe37">RawsockMaxLength::kB_128</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993faad8383143d8cf1211f5563836fd49633">RawsockMaxLength::kB_256</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa14a233b47cc592c5ca2e0c8f9a491819">RawsockMaxLength::kB_512</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa7e97e2cb92202bee510f8f60c8a1731f">RawsockMaxLength::MB_1</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa068279e2835919ba1c26a15639f88417">RawsockMaxLength::MB_2</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa2f62273b1b6d374490403fa82249244c">RawsockMaxLength::MB_4</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fa36fbb1a264212a9d7d50718ab388cdae">RawsockMaxLength::MB_8</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993fab6907cabd72d2874a3bfbfce2f61ba42">RawsockMaxLength::MB_16</a>
<br />
 }</td></tr>
<tr class="memdesc:a1750e952cec62e645c6b1c918c06993f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerators used to specify the maximum length of messages that a raw socket transport can receive.  <a href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993f">More...</a><br /></td></tr>
<tr class="separator:a1750e952cec62e645c6b1c918c06993f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d04d75506649324abb78e785749ccdb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdb">TypeId</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdba37a6259cc0c1dae299a7866489dff0bd">TypeId::null</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdba84e2c64f38f78ba3ea5c905ab5a2da27">TypeId::boolean</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdba157db7df530023575515d366c9b672e8">TypeId::integer</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdba1277b8d5127d0eced2e9d3b99a3a7079">TypeId::uint</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdba4bca24304861acde5770fdbe3cc2503b">TypeId::real</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdbab45cffe084dd3d20d928bee85e7b0f21">TypeId::string</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdbaee26908bf9629eeb4b37dac350f4754a">TypeId::blob</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdbaf1f713c9e000f5d3f280adbd124df4f5">TypeId::array</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdbaa8cfde6331bd59eb2ac96f8911c4b666">TypeId::object</a>
<br />
 }</td></tr>
<tr class="memdesc:a4d04d75506649324abb78e785749ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer ID used to indicate the current dynamic type of a <code>Variant</code>.  <a href="namespacewamp.html#a4d04d75506649324abb78e785749ccdb">More...</a><br /></td></tr>
<tr class="separator:a4d04d75506649324abb78e785749ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba5f85cd0d02bf363dfec7da1b339f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339f">SessionState</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fa3a561116f0c9675a3c83d21fa365050d">SessionState::disconnected</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fa9a27316fbc5ef38b2a19c202dbdc29b7">SessionState::connecting</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fa349e686330723975502e9ef4f939a5ac">SessionState::closed</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339faab0e76e1623e4b9f4b2c6dc8e966989f">SessionState::establishing</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fa3d5d0f5c7a6b281da0b22f8c128fb20e">SessionState::authenticating</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339faa533b26cba9a7c8d891c962473f49ec0">SessionState::established</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fabe3d0ab12e871a97c27100d4a3183ec2">SessionState::shuttingDown</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339fa26934eb377001f66e37289a5c93fe284">SessionState::failed</a>
<br />
 }</td></tr>
<tr class="memdesc:a53ba5f85cd0d02bf363dfec7da1b339f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the possible states that a client or router session can be in.  <a href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339f">More...</a><br /></td></tr>
<tr class="separator:a53ba5f85cd0d02bf363dfec7da1b339f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5fff4d6df9508a521ce3966a80f402"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">CallCancelMode</a> { <br />
&#160;&#160;<a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402a534735884d341071762ede7af01c53e8">CallCancelMode::kill</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402a242f6238202bc24d24474f1b405f6bb7">CallCancelMode::killNoWait</a>, 
<br />
&#160;&#160;<a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402a08b43519a7e36ee4c6c5615d1663bcfd">CallCancelMode::skip</a>
<br />
 }</td></tr>
<tr class="memdesc:ada5fff4d6df9508a521ce3966a80f402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the possible call cancelling modes.  <a href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">More...</a><br /></td></tr>
<tr class="separator:ada5fff4d6df9508a521ce3966a80f402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa819bb46f2e7b186b9414dc1198ddc88"><td class="memTemplParams" colspan="2"><a id="aa819bb46f2e7b186b9414dc1198ddc88"></a>
template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:aa819bb46f2e7b186b9414dc1198ddc88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa819bb46f2e7b186b9414dc1198ddc88">dispatchAny</a> (F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa819bb46f2e7b186b9414dc1198ddc88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the given handler using its associated executor, passing the given arguments. <br /></td></tr>
<tr class="separator:aa819bb46f2e7b186b9414dc1198ddc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5fa517bb22fc0b9ebc988b1cf47982"><td class="memTemplParams" colspan="2"><a id="ada5fa517bb22fc0b9ebc988b1cf47982"></a>
template&lt;typename F , typename E , typename... Ts&gt; </td></tr>
<tr class="memitem:ada5fa517bb22fc0b9ebc988b1cf47982"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ada5fa517bb22fc0b9ebc988b1cf47982">dispatchVia</a> (const E &amp;fallbackExec, F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:ada5fa517bb22fc0b9ebc988b1cf47982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the given handler using the given fallback executor, passing the given arguments. <br /></td></tr>
<tr class="separator:ada5fa517bb22fc0b9ebc988b1cf47982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af44b011da2c321814d65408c464d7e"><td class="memTemplParams" colspan="2"><a id="a6af44b011da2c321814d65408c464d7e"></a>
template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a6af44b011da2c321814d65408c464d7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a6af44b011da2c321814d65408c464d7e">postAny</a> (F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6af44b011da2c321814d65408c464d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts the given handler using its associated executor, passing the given arguments. <br /></td></tr>
<tr class="separator:a6af44b011da2c321814d65408c464d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ea877d15c0c327635ed47f21105f2c"><td class="memTemplParams" colspan="2"><a id="a73ea877d15c0c327635ed47f21105f2c"></a>
template&lt;typename F , typename E , typename... Ts&gt; </td></tr>
<tr class="memitem:a73ea877d15c0c327635ed47f21105f2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a73ea877d15c0c327635ed47f21105f2c">postVia</a> (const E &amp;fallbackExec, F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a73ea877d15c0c327635ed47f21105f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts the given handler using the given fallback executor, passing the given arguments. <br /></td></tr>
<tr class="separator:a73ea877d15c0c327635ed47f21105f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112d9da77c4d9f6b4282771a425ec984"><td class="memTemplParams" colspan="2"><a id="a112d9da77c4d9f6b4282771a425ec984"></a>
template&lt;typename F , typename... Ts&gt; </td></tr>
<tr class="memitem:a112d9da77c4d9f6b4282771a425ec984"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a112d9da77c4d9f6b4282771a425ec984">deferAny</a> (F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a112d9da77c4d9f6b4282771a425ec984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defers the given handler using its associated executor, passing the given arguments. <br /></td></tr>
<tr class="separator:a112d9da77c4d9f6b4282771a425ec984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa934ec435b7c268c467452a7417ded"><td class="memTemplParams" colspan="2"><a id="acaa934ec435b7c268c467452a7417ded"></a>
template&lt;typename F , typename E , typename... Ts&gt; </td></tr>
<tr class="memitem:acaa934ec435b7c268c467452a7417ded"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#acaa934ec435b7c268c467452a7417ded">deferVia</a> (const E &amp;fallbackExec, F &amp;&amp;handler, Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:acaa934ec435b7c268c467452a7417ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defers the given handler using the given fallback executor, passing the given arguments. <br /></td></tr>
<tr class="separator:acaa934ec435b7c268c467452a7417ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bb6673f3bae26c63ab24239194bc75"><td class="memTemplParams" colspan="2">template&lt;typename TFormat , typename TOutput &gt; </td></tr>
<tr class="memitem:a47bb6673f3bae26c63ab24239194bc75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a47bb6673f3bae26c63ab24239194bc75">encode</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant, TOutput &amp;&amp;output)</td></tr>
<tr class="memdesc:a47bb6673f3bae26c63ab24239194bc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given variant to the given byte container or stream.  <a href="namespacewamp.html#a47bb6673f3bae26c63ab24239194bc75">More...</a><br /></td></tr>
<tr class="separator:a47bb6673f3bae26c63ab24239194bc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2f8f640e5157d6bc85fe8ba79224ac"><td class="memTemplParams" colspan="2">template&lt;typename TFormat , typename TInput &gt; </td></tr>
<tr class="memitem:a2a2f8f640e5157d6bc85fe8ba79224ac"><td class="memTemplItemLeft" align="right" valign="top">std::error_code&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a2a2f8f640e5157d6bc85fe8ba79224ac">decode</a> (TInput &amp;&amp;input, <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant)</td></tr>
<tr class="memdesc:a2a2f8f640e5157d6bc85fe8ba79224ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes from the given byte sequence or stream to the given variant.  <a href="namespacewamp.html#a2a2f8f640e5157d6bc85fe8ba79224ac">More...</a><br /></td></tr>
<tr class="separator:a2a2f8f640e5157d6bc85fe8ba79224ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8cfc7a90d578f0536d7368bcc2d207"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs, typename TSlot &gt; </td></tr>
<tr class="memitem:afc8cfc7a90d578f0536d7368bcc2d207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html">SimpleCoroEventUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#afc8cfc7a90d578f0536d7368bcc2d207">basicCoroEvent</a> (TSlot &amp;&amp;slot)</td></tr>
<tr class="separator:afc8cfc7a90d578f0536d7368bcc2d207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f603aa9cb27a3ae0ab1f8f8ddec1dc"><td class="memTemplParams" colspan="2">template&lt;typename TResult , typename... TArgs, typename TSlot &gt; </td></tr>
<tr class="memitem:a77f603aa9cb27a3ae0ab1f8f8ddec1dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html">SimpleCoroInvocationUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TResult, TArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a77f603aa9cb27a3ae0ab1f8f8ddec1dc">basicCoroRpc</a> (TSlot &amp;&amp;slot)</td></tr>
<tr class="separator:a77f603aa9cb27a3ae0ab1f8f8ddec1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ac454b78decb0e2d32994241961886"><td class="memTemplParams" colspan="2"><a id="aa6ac454b78decb0e2d32994241961886"></a>
template&lt;typename TErrorEnum &gt; </td></tr>
<tr class="memitem:aa6ac454b78decb0e2d32994241961886"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacewamp.html#ac4069b3fda38bf2051619ad71bc76e7b">UnexpectedError</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa6ac454b78decb0e2d32994241961886">makeUnexpectedError</a> (TErrorEnum errc)</td></tr>
<tr class="memdesc:aa6ac454b78decb0e2d32994241961886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that creates an UnexpectedError from an error code enum. <br /></td></tr>
<tr class="separator:aa6ac454b78decb0e2d32994241961886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26df4a87f37269f63b6e8ccd15e13937"><td class="memTemplParams" colspan="2"><a id="a26df4a87f37269f63b6e8ccd15e13937"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a26df4a87f37269f63b6e8ccd15e13937"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a26df4a87f37269f63b6e8ccd15e13937">isSameType</a> ()</td></tr>
<tr class="memdesc:a26df4a87f37269f63b6e8ccd15e13937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a type is the same as another. <br /></td></tr>
<tr class="separator:a26df4a87f37269f63b6e8ccd15e13937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211d07a7169feb6b6e9cd351bf378841"><td class="memTemplParams" colspan="2"><a id="a211d07a7169feb6b6e9cd351bf378841"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a211d07a7169feb6b6e9cd351bf378841"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a211d07a7169feb6b6e9cd351bf378841">isBool</a> ()</td></tr>
<tr class="memdesc:a211d07a7169feb6b6e9cd351bf378841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given type is considered a boolean. <br /></td></tr>
<tr class="separator:a211d07a7169feb6b6e9cd351bf378841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f60ee29904aa30973713672aa3fc37b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f60ee29904aa30973713672aa3fc37b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a0f60ee29904aa30973713672aa3fc37b">isNumber</a> ()</td></tr>
<tr class="memdesc:a0f60ee29904aa30973713672aa3fc37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given type is considered a number.  <a href="namespacewamp.html#a0f60ee29904aa30973713672aa3fc37b">More...</a><br /></td></tr>
<tr class="separator:a0f60ee29904aa30973713672aa3fc37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951e81963d0cf4855d8930833b907782"><td class="memTemplParams" colspan="2"><a id="a951e81963d0cf4855d8930833b907782"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a951e81963d0cf4855d8930833b907782"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a951e81963d0cf4855d8930833b907782">isSignedInteger</a> ()</td></tr>
<tr class="memdesc:a951e81963d0cf4855d8930833b907782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given type is a signed integer. <br /></td></tr>
<tr class="separator:a951e81963d0cf4855d8930833b907782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c38865623683d342e8cc3a4671c940"><td class="memTemplParams" colspan="2"><a id="a14c38865623683d342e8cc3a4671c940"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14c38865623683d342e8cc3a4671c940"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a14c38865623683d342e8cc3a4671c940">isUnsignedInteger</a> ()</td></tr>
<tr class="memdesc:a14c38865623683d342e8cc3a4671c940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given type is an unsigned integer. <br /></td></tr>
<tr class="separator:a14c38865623683d342e8cc3a4671c940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d94efc6083f316ca03b828d2a64fd8"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs, typename TSlot &gt; </td></tr>
<tr class="memitem:ae2d94efc6083f316ca03b828d2a64fd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwamp_1_1_simple_event_unpacker.html">SimpleEventUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ae2d94efc6083f316ca03b828d2a64fd8">basicEvent</a> (TSlot &amp;&amp;slot)</td></tr>
<tr class="separator:ae2d94efc6083f316ca03b828d2a64fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2b0875bbaf5d9605135d405a43a7ea"><td class="memTemplParams" colspan="2">template&lt;typename TResult , typename... TArgs, typename TSlot &gt; </td></tr>
<tr class="memitem:add2b0875bbaf5d9605135d405a43a7ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwamp_1_1_simple_invocation_unpacker.html">SimpleInvocationUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TResult, TArgs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#add2b0875bbaf5d9605135d405a43a7ea">basicRpc</a> (TSlot &amp;&amp;slot)</td></tr>
<tr class="separator:add2b0875bbaf5d9605135d405a43a7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a84cb7bb559428594ebfb21c07a8935"><td class="memTemplParams" colspan="2">template&lt;typename TConverter , typename TValue , DisableIf&lt; std::is_enum&lt; TValue &gt;::value &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9a84cb7bb559428594ebfb21c07a8935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9a84cb7bb559428594ebfb21c07a8935">convert</a> (TConverter &amp;c, TValue &amp;val)</td></tr>
<tr class="memdesc:a9a84cb7bb559428594ebfb21c07a8935"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for converting custom types to/from <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>.  <a href="namespacewamp.html#a9a84cb7bb559428594ebfb21c07a8935">More...</a><br /></td></tr>
<tr class="separator:a9a84cb7bb559428594ebfb21c07a8935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9044150137eb658a1699521784649865"><td class="memTemplParams" colspan="2"><a id="a9044150137eb658a1699521784649865"></a>
template&lt;typename TEnum , EnableIf&lt; std::is_enum&lt; TEnum &gt;::value &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9044150137eb658a1699521784649865"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9044150137eb658a1699521784649865">convert</a> (const <a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;c, TEnum &amp;e)</td></tr>
<tr class="memdesc:a9044150137eb658a1699521784649865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an integer variant to an enumerator. <br /></td></tr>
<tr class="separator:a9044150137eb658a1699521784649865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4910f2b9267b074f9ea959a7b8f450"><td class="memTemplParams" colspan="2"><a id="afa4910f2b9267b074f9ea959a7b8f450"></a>
template&lt;typename TEnum , EnableIf&lt; std::is_enum&lt; TEnum &gt;::value &gt;  = 0&gt; </td></tr>
<tr class="memitem:afa4910f2b9267b074f9ea959a7b8f450"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#afa4910f2b9267b074f9ea959a7b8f450">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;c, const TEnum &amp;e)</td></tr>
<tr class="memdesc:afa4910f2b9267b074f9ea959a7b8f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an enumerator to an integer variant. <br /></td></tr>
<tr class="separator:afa4910f2b9267b074f9ea959a7b8f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7124cf7175556a3c2190d860bf1416"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3d7124cf7175556a3c2190d860bf1416">lookupWampErrorUri</a> (const std::string &amp;uri, <a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">SessionErrc</a> fallback, <a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">SessionErrc</a> &amp;result)</td></tr>
<tr class="separator:a3d7124cf7175556a3c2190d860bf1416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cffe721e4c495c1733c6985b894db1c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t Size&gt; </td></tr>
<tr class="memitem:a6cffe721e4c495c1733c6985b894db1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a6cffe721e4c495c1733c6985b894db1c">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::array&lt; T, Size &gt; &amp;array)</td></tr>
<tr class="memdesc:a6cffe721e4c495c1733c6985b894db1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from an array variant to a <code>std::array</code>.  <a href="namespacewamp.html#a6cffe721e4c495c1733c6985b894db1c">More...</a><br /></td></tr>
<tr class="separator:a6cffe721e4c495c1733c6985b894db1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fae3bba144889572782ffc020cd8f5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t Size&gt; </td></tr>
<tr class="memitem:a06fae3bba144889572782ffc020cd8f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a06fae3bba144889572782ffc020cd8f5">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::array&lt; T, Size &gt; &amp;array)</td></tr>
<tr class="memdesc:a06fae3bba144889572782ffc020cd8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a <code>std::array</code> to an array variant.  <a href="namespacewamp.html#a06fae3bba144889572782ffc020cd8f5">More...</a><br /></td></tr>
<tr class="separator:a06fae3bba144889572782ffc020cd8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d10382ab0957a5457c4e48dfad3ee58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d10382ab0957a5457c4e48dfad3ee58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a4d10382ab0957a5457c4e48dfad3ee58">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, boost::optional&lt; T &gt; &amp;opt)</td></tr>
<tr class="memdesc:a4d10382ab0957a5457c4e48dfad3ee58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a variant to a boost::optional.  <a href="namespacewamp.html#a4d10382ab0957a5457c4e48dfad3ee58">More...</a><br /></td></tr>
<tr class="separator:a4d10382ab0957a5457c4e48dfad3ee58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99c56e5890f2b65b900921126dfba32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad99c56e5890f2b65b900921126dfba32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ad99c56e5890f2b65b900921126dfba32">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, boost::optional&lt; T &gt; &amp;opt)</td></tr>
<tr class="memdesc:ad99c56e5890f2b65b900921126dfba32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a boost::optional to a variant.  <a href="namespacewamp.html#ad99c56e5890f2b65b900921126dfba32">More...</a><br /></td></tr>
<tr class="separator:ad99c56e5890f2b65b900921126dfba32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6214de3c21a3e729e15f2118d1aef89f"><td class="memTemplParams" colspan="2"><a id="a6214de3c21a3e729e15f2118d1aef89f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6214de3c21a3e729e15f2118d1aef89f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a6214de3c21a3e729e15f2118d1aef89f">operator==</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v, const boost::optional&lt; T &gt; o)</td></tr>
<tr class="memdesc:a6214de3c21a3e729e15f2118d1aef89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>boost::optional</code> for equality. <br /></td></tr>
<tr class="separator:a6214de3c21a3e729e15f2118d1aef89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a04bc7fba47b5006ae1389a3590b2f3"><td class="memTemplParams" colspan="2"><a id="a3a04bc7fba47b5006ae1389a3590b2f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a04bc7fba47b5006ae1389a3590b2f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3a04bc7fba47b5006ae1389a3590b2f3">operator==</a> (const boost::optional&lt; T &gt; o, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v)</td></tr>
<tr class="memdesc:a3a04bc7fba47b5006ae1389a3590b2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>boost::optional</code> for equality. <br /></td></tr>
<tr class="separator:a3a04bc7fba47b5006ae1389a3590b2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5db5af57136c463e73297b58bfa344"><td class="memTemplParams" colspan="2"><a id="a9e5db5af57136c463e73297b58bfa344"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e5db5af57136c463e73297b58bfa344"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9e5db5af57136c463e73297b58bfa344">operator!=</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v, const boost::optional&lt; T &gt; o)</td></tr>
<tr class="memdesc:a9e5db5af57136c463e73297b58bfa344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>boost::optional</code> for inequality. <br /></td></tr>
<tr class="separator:a9e5db5af57136c463e73297b58bfa344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7aa1266a33176883d78aa69e8371a0"><td class="memTemplParams" colspan="2"><a id="a0f7aa1266a33176883d78aa69e8371a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f7aa1266a33176883d78aa69e8371a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a0f7aa1266a33176883d78aa69e8371a0">operator!=</a> (const boost::optional&lt; T &gt; o, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v)</td></tr>
<tr class="memdesc:a0f7aa1266a33176883d78aa69e8371a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>boost::optional</code> for inequality. <br /></td></tr>
<tr class="separator:a0f7aa1266a33176883d78aa69e8371a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f3f98c3d797a8610ccb20d9d68394"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa61f3f98c3d797a8610ccb20d9d68394"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa61f3f98c3d797a8610ccb20d9d68394">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::optional&lt; T &gt; &amp;opt)</td></tr>
<tr class="memdesc:aa61f3f98c3d797a8610ccb20d9d68394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a variant to a std::optional.  <a href="namespacewamp.html#aa61f3f98c3d797a8610ccb20d9d68394">More...</a><br /></td></tr>
<tr class="separator:aa61f3f98c3d797a8610ccb20d9d68394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306f456b677ab40e11b6fa0f21d709fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a306f456b677ab40e11b6fa0f21d709fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a306f456b677ab40e11b6fa0f21d709fa">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::optional&lt; T &gt; &amp;opt)</td></tr>
<tr class="memdesc:a306f456b677ab40e11b6fa0f21d709fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a std::optional to a variant.  <a href="namespacewamp.html#a306f456b677ab40e11b6fa0f21d709fa">More...</a><br /></td></tr>
<tr class="separator:a306f456b677ab40e11b6fa0f21d709fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed414f2ee4bce41d141e8f00c3b7d20"><td class="memTemplParams" colspan="2"><a id="a9ed414f2ee4bce41d141e8f00c3b7d20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ed414f2ee4bce41d141e8f00c3b7d20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9ed414f2ee4bce41d141e8f00c3b7d20">operator==</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v, const std::optional&lt; T &gt; o)</td></tr>
<tr class="memdesc:a9ed414f2ee4bce41d141e8f00c3b7d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>std::optional</code> for equality. <br /></td></tr>
<tr class="separator:a9ed414f2ee4bce41d141e8f00c3b7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bdbf10e2b5afbb4f23d123b9b1d891"><td class="memTemplParams" colspan="2"><a id="a91bdbf10e2b5afbb4f23d123b9b1d891"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91bdbf10e2b5afbb4f23d123b9b1d891"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a91bdbf10e2b5afbb4f23d123b9b1d891">operator==</a> (const std::optional&lt; T &gt; o, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v)</td></tr>
<tr class="memdesc:a91bdbf10e2b5afbb4f23d123b9b1d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>std::optional</code> for equality. <br /></td></tr>
<tr class="separator:a91bdbf10e2b5afbb4f23d123b9b1d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041748da7bc3fe2cd5fbf05629476f7c"><td class="memTemplParams" colspan="2"><a id="a041748da7bc3fe2cd5fbf05629476f7c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a041748da7bc3fe2cd5fbf05629476f7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a041748da7bc3fe2cd5fbf05629476f7c">operator!=</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v, const std::optional&lt; T &gt; o)</td></tr>
<tr class="memdesc:a041748da7bc3fe2cd5fbf05629476f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>std::optional</code> for inequality. <br /></td></tr>
<tr class="separator:a041748da7bc3fe2cd5fbf05629476f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac55b3b6f11c19cd4ffd86f7ce075e9"><td class="memTemplParams" colspan="2"><a id="a5ac55b3b6f11c19cd4ffd86f7ce075e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ac55b3b6f11c19cd4ffd86f7ce075e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a5ac55b3b6f11c19cd4ffd86f7ce075e9">operator!=</a> (const std::optional&lt; T &gt; o, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;v)</td></tr>
<tr class="memdesc:a5ac55b3b6f11c19cd4ffd86f7ce075e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a variant and a <code>std::optional</code> for inequality. <br /></td></tr>
<tr class="separator:a5ac55b3b6f11c19cd4ffd86f7ce075e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac455de8fa2a3e27d049f0ee03984b840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac455de8fa2a3e27d049f0ee03984b840"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ac455de8fa2a3e27d049f0ee03984b840">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:ac455de8fa2a3e27d049f0ee03984b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from an array variant to a <code>std::set</code>.  <a href="namespacewamp.html#ac455de8fa2a3e27d049f0ee03984b840">More...</a><br /></td></tr>
<tr class="separator:ac455de8fa2a3e27d049f0ee03984b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40665234ed11137bdf50ab60bd8f16e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae40665234ed11137bdf50ab60bd8f16e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ae40665234ed11137bdf50ab60bd8f16e">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:ae40665234ed11137bdf50ab60bd8f16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a <code>std::set</code> to an array variant.  <a href="namespacewamp.html#ae40665234ed11137bdf50ab60bd8f16e">More...</a><br /></td></tr>
<tr class="separator:ae40665234ed11137bdf50ab60bd8f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb775430355bc3fde2a4661fc3e61a8"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a0cb775430355bc3fde2a4661fc3e61a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a0cb775430355bc3fde2a4661fc3e61a8">toTuple</a> (const <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7">wamp::Variant::Array</a> &amp;array, std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a0cb775430355bc3fde2a4661fc3e61a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> to a <code>std::tuple</code>.  <a href="namespacewamp.html#a0cb775430355bc3fde2a4661fc3e61a8">More...</a><br /></td></tr>
<tr class="separator:a0cb775430355bc3fde2a4661fc3e61a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9085e81db59addf5d9fe854a01a993b7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9085e81db59addf5d9fe854a01a993b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7">wamp::Variant::Array</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a9085e81db59addf5d9fe854a01a993b7">toArray</a> (const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a9085e81db59addf5d9fe854a01a993b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code>std::tuple</code> to a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a>.  <a href="namespacewamp.html#a9085e81db59addf5d9fe854a01a993b7">More...</a><br /></td></tr>
<tr class="separator:a9085e81db59addf5d9fe854a01a993b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ece744d0f89e28b123b8cbf71bbdf42"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a0ece744d0f89e28b123b8cbf71bbdf42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a0ece744d0f89e28b123b8cbf71bbdf42">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a0ece744d0f89e28b123b8cbf71bbdf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from an array variant to a <code>std::tuple</code>.  <a href="namespacewamp.html#a0ece744d0f89e28b123b8cbf71bbdf42">More...</a><br /></td></tr>
<tr class="separator:a0ece744d0f89e28b123b8cbf71bbdf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a81787bdd89c19d7094756e3e50895"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a93a81787bdd89c19d7094756e3e50895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a93a81787bdd89c19d7094756e3e50895">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a93a81787bdd89c19d7094756e3e50895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a <code>std::tuple</code> to an array variant.  <a href="namespacewamp.html#a93a81787bdd89c19d7094756e3e50895">More...</a><br /></td></tr>
<tr class="separator:a93a81787bdd89c19d7094756e3e50895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81dd6646124935a228b2c2e00ad05df"><td class="memTemplParams" colspan="2"><a id="aa81dd6646124935a228b2c2e00ad05df"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aa81dd6646124935a228b2c2e00ad05df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#aa81dd6646124935a228b2c2e00ad05df">operator==</a> (const <a class="el" href="namespacewamp.html#a2daa037ae4c3853086e789bad1978ca2">Array</a> &amp;array, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:aa81dd6646124935a228b2c2e00ad05df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> and a <code>std::tuple</code> for equality. <br /></td></tr>
<tr class="separator:aa81dd6646124935a228b2c2e00ad05df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae3bfc8a76acd2ebf266b5a38d1e4e"><td class="memTemplParams" colspan="2"><a id="acbae3bfc8a76acd2ebf266b5a38d1e4e"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:acbae3bfc8a76acd2ebf266b5a38d1e4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#acbae3bfc8a76acd2ebf266b5a38d1e4e">operator==</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const <a class="el" href="namespacewamp.html#a2daa037ae4c3853086e789bad1978ca2">Array</a> &amp;array)</td></tr>
<tr class="memdesc:acbae3bfc8a76acd2ebf266b5a38d1e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>std::tuple</code> and a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> for equality. <br /></td></tr>
<tr class="separator:acbae3bfc8a76acd2ebf266b5a38d1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110196d79196eb95ac5d36e980efa8c1"><td class="memTemplParams" colspan="2"><a id="a110196d79196eb95ac5d36e980efa8c1"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a110196d79196eb95ac5d36e980efa8c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a110196d79196eb95ac5d36e980efa8c1">operator!=</a> (const <a class="el" href="namespacewamp.html#a2daa037ae4c3853086e789bad1978ca2">Array</a> &amp;array, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a110196d79196eb95ac5d36e980efa8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> and a <code>std::tuple</code> for inequality. <br /></td></tr>
<tr class="separator:a110196d79196eb95ac5d36e980efa8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf10d72e01ca8de1bf585ff0730be34"><td class="memTemplParams" colspan="2"><a id="a4cf10d72e01ca8de1bf585ff0730be34"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a4cf10d72e01ca8de1bf585ff0730be34"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a4cf10d72e01ca8de1bf585ff0730be34">operator!=</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const <a class="el" href="namespacewamp.html#a2daa037ae4c3853086e789bad1978ca2">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a4cf10d72e01ca8de1bf585ff0730be34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>std::tuple</code> and a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> for inequality. <br /></td></tr>
<tr class="separator:a4cf10d72e01ca8de1bf585ff0730be34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0fde15652b9e61b4c9d26f37e98bcb"><td class="memTemplParams" colspan="2"><a id="a6d0fde15652b9e61b4c9d26f37e98bcb"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a6d0fde15652b9e61b4c9d26f37e98bcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a6d0fde15652b9e61b4c9d26f37e98bcb">operator==</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a6d0fde15652b9e61b4c9d26f37e98bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> and a <code>std::tuple</code> for equality. <br /></td></tr>
<tr class="separator:a6d0fde15652b9e61b4c9d26f37e98bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad640ebfc9d37e122746cb27f59a0483a"><td class="memTemplParams" colspan="2"><a id="ad640ebfc9d37e122746cb27f59a0483a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad640ebfc9d37e122746cb27f59a0483a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ad640ebfc9d37e122746cb27f59a0483a">operator==</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant)</td></tr>
<tr class="memdesc:ad640ebfc9d37e122746cb27f59a0483a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>std::tuple</code> and a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> for equality. <br /></td></tr>
<tr class="separator:ad640ebfc9d37e122746cb27f59a0483a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5fde707a3aa2918a14fbaa0c2721e4"><td class="memTemplParams" colspan="2"><a id="a3b5fde707a3aa2918a14fbaa0c2721e4"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a3b5fde707a3aa2918a14fbaa0c2721e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3b5fde707a3aa2918a14fbaa0c2721e4">operator!=</a> (const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a3b5fde707a3aa2918a14fbaa0c2721e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> and a <code>std::tuple</code> for inequality. <br /></td></tr>
<tr class="separator:a3b5fde707a3aa2918a14fbaa0c2721e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a4feb343ad779b7cae221bdb638d2d"><td class="memTemplParams" colspan="2"><a id="a39a4feb343ad779b7cae221bdb638d2d"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a39a4feb343ad779b7cae221bdb638d2d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a39a4feb343ad779b7cae221bdb638d2d">operator!=</a> (const std::tuple&lt; Ts... &gt; &amp;tuple, const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;variant)</td></tr>
<tr class="memdesc:a39a4feb343ad779b7cae221bdb638d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>std::tuple</code> and a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> for inequality. <br /></td></tr>
<tr class="separator:a39a4feb343ad779b7cae221bdb638d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de3a8ab4349a5856300872d3e9e8761"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3de3a8ab4349a5856300872d3e9e8761"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a3de3a8ab4349a5856300872d3e9e8761">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::unordered_map&lt; <a class="el" href="namespacewamp.html#a0b58ab2a2761bca711bc957b47619662">String</a>, T &gt; &amp;map)</td></tr>
<tr class="memdesc:a3de3a8ab4349a5856300872d3e9e8761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from an object variant to a <code>std::unordered_map</code>.  <a href="namespacewamp.html#a3de3a8ab4349a5856300872d3e9e8761">More...</a><br /></td></tr>
<tr class="separator:a3de3a8ab4349a5856300872d3e9e8761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc3e63b825b5f6c3fbe497b76d8ef71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfc3e63b825b5f6c3fbe497b76d8ef71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#adfc3e63b825b5f6c3fbe497b76d8ef71">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::unordered_map&lt; <a class="el" href="namespacewamp.html#a0b58ab2a2761bca711bc957b47619662">String</a>, T &gt; &amp;map)</td></tr>
<tr class="memdesc:adfc3e63b825b5f6c3fbe497b76d8ef71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a <code>std::unordered_map</code> to an object variant.  <a href="namespacewamp.html#adfc3e63b825b5f6c3fbe497b76d8ef71">More...</a><br /></td></tr>
<tr class="separator:adfc3e63b825b5f6c3fbe497b76d8ef71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7490642dafbab110c4eda5cd77022f1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7490642dafbab110c4eda5cd77022f1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a7490642dafbab110c4eda5cd77022f1e">convert</a> (<a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;conv, std::unordered_set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:a7490642dafbab110c4eda5cd77022f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from an array variant to a <code>std::unordered_set</code>.  <a href="namespacewamp.html#a7490642dafbab110c4eda5cd77022f1e">More...</a><br /></td></tr>
<tr class="separator:a7490642dafbab110c4eda5cd77022f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a21a5d6aa3174b2b32bf147210413c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27a21a5d6aa3174b2b32bf147210413c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a27a21a5d6aa3174b2b32bf147210413c">convert</a> (<a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;conv, std::unordered_set&lt; T &gt; &amp;set)</td></tr>
<tr class="memdesc:a27a21a5d6aa3174b2b32bf147210413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the conversion from a <code>std::unordered_set</code> to an array variant.  <a href="namespacewamp.html#a27a21a5d6aa3174b2b32bf147210413c">More...</a><br /></td></tr>
<tr class="separator:a27a21a5d6aa3174b2b32bf147210413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a30e2886a93141924f9643770b4f01eef"><td class="memItemLeft" align="right" valign="top"><a id="a30e2886a93141924f9643770b4f01eef"></a>
constexpr <a class="el" href="structwamp_1_1_null.html">Null</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a30e2886a93141924f9643770b4f01eef">null</a></td></tr>
<tr class="memdesc:a30e2886a93141924f9643770b4f01eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant <a class="el" href="structwamp_1_1_null.html" title="Type used to represent a null or empty Variant value.">Null</a> object that can be assigned to, or compared with a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>. <br /></td></tr>
<tr class="separator:a30e2886a93141924f9643770b4f01eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9817fe38224a0e5fc43ca9cdbce4716"><td class="memItemLeft" align="right" valign="top"><a id="ab9817fe38224a0e5fc43ca9cdbce4716"></a>
constexpr <a class="el" href="structwamp_1_1_deferment.html">Deferment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#ab9817fe38224a0e5fc43ca9cdbce4716">deferment</a></td></tr>
<tr class="memdesc:ab9817fe38224a0e5fc43ca9cdbce4716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient value of the <a class="el" href="structwamp_1_1_deferment.html" title="Tag type that can be passed to wamp::Outcome to construct a deferred outcome.">wamp::Deferment</a> tag type that can be passed to the <a class="el" href="classwamp_1_1_outcome.html" title="Contains the outcome of an RPC invocation.">wamp::Outcome</a> constructor. <br /></td></tr>
<tr class="separator:ab9817fe38224a0e5fc43ca9cdbce4716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614811ceedef97ccc1712e961ab4011e"><td class="memItemLeft" align="right" valign="top"><a id="a614811ceedef97ccc1712e961ab4011e"></a>
constexpr <a class="el" href="structwamp_1_1_thread_safe.html">ThreadSafe</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacewamp.html#a614811ceedef97ccc1712e961ab4011e">threadSafe</a></td></tr>
<tr class="memdesc:a614811ceedef97ccc1712e961ab4011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant <a class="el" href="structwamp_1_1_thread_safe.html" title="Tag type used to specify than an operation is to be dispatched via the called objects&#39;s execution str...">ThreadSafe</a> object instance that can be passed to functions. <br /></td></tr>
<tr class="separator:a614811ceedef97ccc1712e961ab4011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for all identifiers defined by the CppWAMP library. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structwamp_1_1_byte_array_input_category" id="structwamp_1_1_byte_array_input_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_byte_array_input_category">&#9670;&nbsp;</a></span>wamp::ByteArrayInputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::ByteArrayInputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Input category for contiguous byte arrays which provide <code>data</code> and <code>size</code> member functions. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_byte_container_output_category" id="structwamp_1_1_byte_container_output_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_byte_container_output_category">&#9670;&nbsp;</a></span>wamp::ByteContainerOutputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::ByteContainerOutputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Output category for containers of bytes which provide <code>push_back</code> and <code>insert</code> member functions. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_input_category" id="structwamp_1_1_input_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_input_category">&#9670;&nbsp;</a></span>wamp::InputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::InputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename I, typename Enabled = void&gt;<br />
struct wamp::InputCategory&lt; I, Enabled &gt;</h3>

<p>Traits class that determines the category type that best matches the given input type. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_output_category" id="structwamp_1_1_output_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_output_category">&#9670;&nbsp;</a></span>wamp::OutputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::OutputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename O, typename Enabled = void&gt;<br />
struct wamp::OutputCategory&lt; O, Enabled &gt;</h3>

<p>Traits class that determines the category type that best matches the given output type. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_stream_input_category" id="structwamp_1_1_stream_input_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_stream_input_category">&#9670;&nbsp;</a></span>wamp::StreamInputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::StreamInputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Input category for input streams of bytes. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_stream_output_category" id="structwamp_1_1_stream_output_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_stream_output_category">&#9670;&nbsp;</a></span>wamp::StreamOutputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::StreamOutputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Output category for output streams of bytes. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_unknown_input_category" id="structwamp_1_1_unknown_input_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_unknown_input_category">&#9670;&nbsp;</a></span>wamp::UnknownInputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::UnknownInputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Type used to indicate input category detection failed. </p>
</div>
</div>
</div>
<a name="structwamp_1_1_unknown_output_category" id="structwamp_1_1_unknown_output_category"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structwamp_1_1_unknown_output_category">&#9670;&nbsp;</a></span>wamp::UnknownOutputCategory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct wamp::UnknownOutputCategory</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Type used to indicate output category detection failed. </p>
</div>
</div>
</div>
<a name="classwamp_1_1_visitor" id="classwamp_1_1_visitor"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classwamp_1_1_visitor">&#9670;&nbsp;</a></span>wamp::Visitor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class wamp::Visitor</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename TResult = void&gt;<br />
class wamp::Visitor&lt; TResult &gt;</h3>

<p>Convenience base class used to meet the result type requirements of a <a class="el" href="_visitor_concept.html#StaticVisitor">StaticVisitor</a>. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ac5bb22f55faabf451dd06dab64f1f46b"></a>typedef TResult</td>
<td class="fieldname">
Result</td>
<td class="fielddoc">
The return type for all of the visitor's dispatch functions. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af6509d647b5ebde3dfb56bef0e7fcea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6509d647b5ebde3dfb56bef0e7fcea4">&#9670;&nbsp;</a></span>AnyCompletionHandler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSignature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#af6509d647b5ebde3dfb56bef0e7fcea4">wamp::AnyCompletionHandler</a> = typedef boost::asio::any_completion_handler&lt;TSignature&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type-erases a one-shot (and possibly move-only) asynchronous completion handler. </p>
<p>The executor associated with the type-erased handler can be obtained via <a href="https://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/get_associated_executor.html">boost::asio::get_associated_executor</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewamp.html#aa11625cd4da3b272d07186ecbfba2811" title="Type-erases an executor that is to be used with type-erased handlers.">AnyCompletionExecutor</a> </dd>
<dd>
<a class="el" href="classwamp_1_1_any_reusable_handler.html" title="Type-erases a multi-shot, copyable callback handler.">AnyReusableHandler</a> </dd></dl>

</div>
</div>
<a id="ac09b74da0f1191be8b20ae04161c14c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09b74da0f1191be8b20ae04161c14c3">&#9670;&nbsp;</a></span>AnyExecutor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#ac09b74da0f1191be8b20ae04161c14c3">wamp::AnyExecutor</a> = typedef <a class="el" href="namespacewamp.html#a1a6c1d3b5bec84434d0b3c472d2c3f93">AnyIoExecutor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias of AnyIoExecutor kept for backward compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespacewamp.html#a1a6c1d3b5bec84434d0b3c472d2c3f93" title="Polymorphic executor for all I/O objects.">wamp::AnyIoExecutor</a> instead. </dd></dl>

</div>
</div>
<a id="a24590d6853d0156e07654228b3b1db7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24590d6853d0156e07654228b3b1db7e">&#9670;&nbsp;</a></span>AsioService</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a24590d6853d0156e07654228b3b1db7e">wamp::AsioService</a> = typedef <a class="el" href="namespacewamp.html#a9dd954da85bf9033739185b3a29e3e85">AsioContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias of AsioContext kept for backward compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="namespacewamp.html#a9dd954da85bf9033739185b3a29e3e85" title="Queues and runs I/O completion handlers.">wamp::AsioContext</a> instead. </dd></dl>

</div>
</div>
<a id="a7c9cb853e7659f333d612681d98d4e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9cb853e7659f333d612681d98d4e11">&#9670;&nbsp;</a></span>AsyncResult</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a7c9cb853e7659f333d612681d98d4e11">wamp::AsyncResult</a> = typedef <a class="el" href="classwamp_1_1_error_or.html">ErrorOr</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Backward compatiblity type alias.</dd></dl>

</div>
</div>
<a id="a3a4f63f74b0ede851c60223ecf3674e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4f63f74b0ede851c60223ecf3674e5">&#9670;&nbsp;</a></span>Encoder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename O , typename C  = OutputCategoryTypeOf&lt;O&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5">wamp::Encoder</a> = typedef typename F::template <a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5">Encoder</a>&lt;<a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt;O&gt;, C&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields the encoder type needed to encode a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> to the given output type and output category. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Encoder format type tag (e.g. <a class="el" href="structwamp_1_1_json.html" title="JSON format tag type.">Json</a>) </td></tr>
    <tr><td class="paramname">O</td><td>Output type (e.g. std::string) </td></tr>
    <tr><td class="paramname">C</td><td>Output category (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e" title="Yields the decoder type needed to decode a Variant from the given input type and input category.">wamp::Decoder</a> </dd>
<dd>
<a class="el" href="namespacewamp.html#a47bb6673f3bae26c63ab24239194bc75" title="Encodes the given variant to the given byte container or stream.">wamp::encode</a> </dd></dl>

</div>
</div>
<a id="a612977014a4cf2e1d8f58406b95d0e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612977014a4cf2e1d8f58406b95d0e6e">&#9670;&nbsp;</a></span>Decoder</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename I , typename C  = InputCategoryTypeOf&lt;I&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e">wamp::Decoder</a> = typedef typename F::template <a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e">Decoder</a>&lt;<a class="el" href="namespacewamp.html#aefe046bb975ae7fe4ddccc4e4e234a1d">ValueTypeOf</a>&lt;I&gt;, C&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields the decoder type needed to decode a <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a> from the given input type and input category. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>Encoder format type tag (e.g. <a class="el" href="structwamp_1_1_json.html" title="JSON format tag type.">Json</a>) </td></tr>
    <tr><td class="paramname">I</td><td>Input type (e.g. std::string) </td></tr>
    <tr><td class="paramname">I</td><td>Input category (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5" title="Yields the encoder type needed to encode a Variant to the given output type and output category.">wamp::Encoder</a> </dd>
<dd>
<a class="el" href="namespacewamp.html#a2a2f8f640e5157d6bc85fe8ba79224ac" title="Decodes from the given byte sequence or stream to the given variant.">wamp::decode</a> </dd></dl>

</div>
</div>
<a id="a60f634581655053f937d8d405a6126c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f634581655053f937d8d405a6126c9">&#9670;&nbsp;</a></span>BasicCoroEventUnpacker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSlot , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a60f634581655053f937d8d405a6126c9">wamp::BasicCoroEventUnpacker</a> = typedef <a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html">SimpleCoroEventUnpacker</a>&lt;TSlot, TArgs...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to <a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleCoroEventUnpacker</a> kept for backward compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use <a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleCoroEventUnpacker</a> instead. </dd></dl>

</div>
</div>
<a id="a3c048c8cb747c215876982c8b2f7b394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c048c8cb747c215876982c8b2f7b394">&#9670;&nbsp;</a></span>BasicCoroInvocationUnpacker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSlot , typename TResult , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a3c048c8cb747c215876982c8b2f7b394">wamp::BasicCoroInvocationUnpacker</a> = typedef <a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html">SimpleCoroInvocationUnpacker</a>&lt;TSlot, TResult, TArgs...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to <a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleCoroInvocationUnpacker</a> kept for backward compability. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleCoroInvocationUnpacker</a> instead. </dd></dl>

</div>
</div>
<a id="a22abefe77bf3705196e2e756a0c134b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22abefe77bf3705196e2e756a0c134b8">&#9670;&nbsp;</a></span>Cancellation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a22abefe77bf3705196e2e756a0c134b8">wamp::Cancellation</a> = typedef <a class="el" href="classwamp_1_1_call_cancellation.html">CallCancellation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias of <a class="el" href="classwamp_1_1_call_cancellation.html" title="Contains the request ID and options contained within WAMP CANCEL messages.">CallCancellation</a> kept for backward compatiblity. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use <a class="el" href="classwamp_1_1_call_cancellation.html" title="Contains the request ID and options contained within WAMP CANCEL messages.">wamp::CallCancellation</a> instead. </dd></dl>

</div>
</div>
<a id="a3ba148e03444eba9aa3d9c0f770883d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba148e03444eba9aa3d9c0f770883d5">&#9670;&nbsp;</a></span>BasicEventUnpacker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSlot , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#a3ba148e03444eba9aa3d9c0f770883d5">wamp::BasicEventUnpacker</a> = typedef <a class="el" href="classwamp_1_1_simple_event_unpacker.html">SimpleEventUnpacker</a>&lt;TSlot, TArgs...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to <a class="el" href="classwamp_1_1_simple_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleEventUnpacker</a> kept for backward compatiblity. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000048">Deprecated:</a></b></dt><dd>Use <a class="el" href="classwamp_1_1_simple_event_unpacker.html" title="Wrapper around an event slot which automatically unpacks positional payload arguments.">SimpleEventUnpacker</a> instead. </dd></dl>

</div>
</div>
<a id="aa434cc11de6a09adcf68f1e25258e980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa434cc11de6a09adcf68f1e25258e980">&#9670;&nbsp;</a></span>BasicInvocationUnpacker</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSlot , typename TResult , typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#aa434cc11de6a09adcf68f1e25258e980">wamp::BasicInvocationUnpacker</a> = typedef <a class="el" href="classwamp_1_1_simple_invocation_unpacker.html">SimpleInvocationUnpacker</a>&lt;TSlot, TResult, TArgs...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to <a class="el" href="classwamp_1_1_simple_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleInvocationUnpacker</a> kept for backward compability. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>Use <a class="el" href="classwamp_1_1_simple_invocation_unpacker.html" title="Wrapper around a call slot which automatically unpacks positional payload arguments.">SimpleInvocationUnpacker</a> instead. </dd></dl>

</div>
</div>
<a id="aec6569c4e9bd084777aea6cf8ee0fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6569c4e9bd084777aea6cf8ee0fea6">&#9670;&nbsp;</a></span>CancelMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">wamp::CancelMode</a> = typedef <a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">CallCancelMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to CallCancelMode kept for backward compatibility. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>Use CallCancelMode instead. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9ecf2a0b15a4d67bb0cd1928b4056d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecf2a0b15a4d67bb0cd1928b4056d46">&#9670;&nbsp;</a></span>SessionErrc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">wamp::SessionErrc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error code values used with the <a class="el" href="classwamp_1_1_session_category.html" title="std::error_category used for reporting errors at the WAMP session layer.">SessionCategory</a> error category. </p>
<p>The equivalencies between these codes are as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">std::error_code </th><th class="markdownTableHeadNone">Equivalent condition value  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make_error_code(noSuchRealm) </td><td class="markdownTableBodyNone">joinError  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">make_error_code(noSuchRole) </td><td class="markdownTableBodyNone">joinError  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make_error_code(systemShutdown) </td><td class="markdownTableBodyNone">sessionEndedByPeer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">make_error_code(closeRealm) </td><td class="markdownTableBodyNone">sessionEndedByPeer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make_error_code(noSuchSubscription) </td><td class="markdownTableBodyNone">unsubscribeError  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">make_error_code(procedureAlreadyExists) </td><td class="markdownTableBodyNone">registerError  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">make_error_code(noSuchProcedure) </td><td class="markdownTableBodyNone">callError  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">make_error_code(invalidArgument) </td><td class="markdownTableBodyNone">callError  </td></tr>
</table>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Operation successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a6398ee39c528ff4737ae63947d85d0a4"></a>sessionEnded&#160;</td><td class="fielddoc"><p>Operation aborted; session ended by this peer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a31d993ba59164643e0e2159e32b63216"></a>sessionEndedByPeer&#160;</td><td class="fielddoc"><p><a class="el" href="classwamp_1_1_session.html" title="Session API used by a client peer in WAMP applications.">Session</a> ended by other peer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ae55e2d2dad2f8cb947d320333e4fd018"></a>allTransportsFailed&#160;</td><td class="fielddoc"><p>All transports failed during connection. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46aa75d537e41b81dbfe97193fbc3c1a31c"></a>joinError&#160;</td><td class="fielddoc"><p>Join error reported by router. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a829ceab85261d613afb28a51c65891fc"></a>publishError&#160;</td><td class="fielddoc"><p>Publish error reported by broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a696e8572fae9cf279b6ae706bb198067"></a>subscribeError&#160;</td><td class="fielddoc"><p>Subscribe error reported by broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a0af961c159db3c2e12ecefdcdd067f5d"></a>unsubscribeError&#160;</td><td class="fielddoc"><p>Unsubscribe error reported by broker. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a5df9f1bf5e3db9c58bf704975f5b910b"></a>registerError&#160;</td><td class="fielddoc"><p>Register error reported by dealer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a46b3700b2b31b8385fe1d8ee86467afd"></a>unregisterError&#160;</td><td class="fielddoc"><p>Unregister error reported by dealer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46aef60a5ac24513b778c5cbf1c19849ade"></a>callError&#160;</td><td class="fielddoc"><p>Call error reported by callee or dealer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a34cbbc3e440497e007985a72c5ba90e0"></a>invalidState&#160;</td><td class="fielddoc"><p>Invalid state for this operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a2bea66a21ec3d2c8e0f5e53525b8ef7d"></a>invalidUri&#160;</td><td class="fielddoc"><p>An invalid WAMP URI was provided. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a2be9ffd8006ede69e1a0d3e504095d14"></a>noSuchProcedure&#160;</td><td class="fielddoc"><p>No procedure was registered under the given URI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a357062fb324f21ba4ec07cdc0af68164"></a>procedureAlreadyExists&#160;</td><td class="fielddoc"><p>A procedure with the given URI is already registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ac76490ae5599680eded015233639c5d2"></a>noSuchRegistration&#160;</td><td class="fielddoc"><p>Could not unregister; the given registration is not active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ac2887dee431a49d9f0ae352716e50de6"></a>noSuchSubscription&#160;</td><td class="fielddoc"><p>Could not unsubscribe; the given subscription is not active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ac37ace0e876e37d499a382934104b9eb"></a>invalidArgument&#160;</td><td class="fielddoc"><p>The given argument types/values are not acceptable to the called procedure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a4e0fa97322f86ae1189c874d9627e843"></a>systemShutdown&#160;</td><td class="fielddoc"><p>The other peer is shutting down. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a99e3020a29f7fdcf1d466029c15f96db"></a>closeRealm&#160;</td><td class="fielddoc"><p>The other peer is leaving the realm. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a9c34b6023aecaad53774bb3c621510d7"></a>goodbyeAndOut&#160;</td><td class="fielddoc"><p><a class="el" href="classwamp_1_1_session.html" title="Session API used by a client peer in WAMP applications.">Session</a> ended successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46afd6ddc515a5476fed223435c88a937b1"></a>notAuthorized&#160;</td><td class="fielddoc"><p>This peer is not authorized to perform the operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a23326a67dfb49576ae6d7f0ed9d124eb"></a>authorizationFailed&#160;</td><td class="fielddoc"><p>The authorization operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a1f7f92026f85b91bf2c50b57390b12a6"></a>noSuchRealm&#160;</td><td class="fielddoc"><p>Attempt to join non-existent realm. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ae36499a907b854bc2d653d1a28d48490"></a>noSuchRole&#160;</td><td class="fielddoc"><p>Attempt to authenticate under unsupported role. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a38881e0a24039dc2621e1d6f86cb71f7"></a>cancelled&#160;</td><td class="fielddoc"><p>A previously issued call was cancelled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46a1de736abaefb5aee04f3c4e04a6fa221"></a>optionNotAllowed&#160;</td><td class="fielddoc"><p>Option is disallowed by the router. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46ae8dbf1dde2318304f49bb205815f7fcd"></a>noEligibleCallee&#160;</td><td class="fielddoc"><p>Call options lead to the exclusion of all callees providing the procedure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46afcceb3a3542cd0fdf32c652a1ea05395"></a>discloseMeDisallowed&#160;</td><td class="fielddoc"><p>Router rejected client request to disclose its identity. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ecf2a0b15a4d67bb0cd1928b4056d46af77654d8b67758cba023bfc9de1464b4"></a>networkFailure&#160;</td><td class="fielddoc"><p>Router encountered a network failure. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6780fafb8e86182dabb1d5eddc9cc784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6780fafb8e86182dabb1d5eddc9cc784">&#9670;&nbsp;</a></span>DecodingErrc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784">wamp::DecodingErrc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error code values used with the <a class="el" href="classwamp_1_1_decoding_category.html" title="std::error_category used for reporting deserialization errors.">DecodingCategory</a> error category. </p>
<p>All of the following non-zero codes are equivalent to the <a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784a3ee28fe1a60c95b89d29317f122c7021" title="Decoding failed.">DecodingErrc::failure</a> condition:</p><ul>
<li><a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784" title="Error code values used with the DecodingCategory error category.">wamp::DecodingErrc</a></li>
<li><code>jsoncons::json_errc</code></li>
<li><code>jsoncons::cbor::cbor_errc</code></li>
<li><code>jsoncons::msgpack::msgpack_errc</code> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784a260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Operation succesful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784a3ee28fe1a60c95b89d29317f122c7021"></a>failure&#160;</td><td class="fielddoc"><p>Decoding failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784a6ed8ac20ecdf679c91e80432006ee832"></a>emptyInput&#160;</td><td class="fielddoc"><p>Input is empty or has no tokens. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784aefb00f8fd8f4a6c2018e90e91a891853"></a>expectedStringKey&#160;</td><td class="fielddoc"><p>Expected a string key. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784aff853bf855be9fdb7dbfa594e945e89b"></a>badBase64Length&#160;</td><td class="fielddoc"><p>Invalid Base64 string length. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784aec7221812154d114d010d55f855767bc"></a>badBase64Padding&#160;</td><td class="fielddoc"><p>Invalid Base64 padding. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6780fafb8e86182dabb1d5eddc9cc784a962217c287faa972012b3142bd7d841c"></a>badBase64Char&#160;</td><td class="fielddoc"><p>Invalid Base64 character. </p>
</td></tr>
</table>

</div>
</div>
<a id="a19ce4bc9c1e5512cec6ba323c4d324d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ce4bc9c1e5512cec6ba323c4d324d0">&#9670;&nbsp;</a></span>ProtocolErrc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0">wamp::ProtocolErrc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error code values used with the <a class="el" href="classwamp_1_1_protocol_category.html" title="std::error_category used for reporting protocol errors related to invalid WAMP messages.">ProtocolCategory</a> error category. </p>
<p>All of the following non-zero codes are equivalent to the <a class="el" href="namespacewamp.html#a19ce4bc9c1e5512cec6ba323c4d324d0ad964fd778dc00a01e79c21066e53a6fe" title="Error decoding WAMP message payload.">ProtocolErrc::badDecode</a> condition:</p><ul>
<li><a class="el" href="namespacewamp.html#a6780fafb8e86182dabb1d5eddc9cc784" title="Error code values used with the DecodingCategory error category.">wamp::DecodingErrc</a></li>
<li><code>jsoncons::json_errc</code></li>
<li><code>jsoncons::cbor::cbor_errc</code></li>
<li><code>jsoncons::msgpack::msgpack_errc</code> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a19ce4bc9c1e5512cec6ba323c4d324d0a260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Operation successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ce4bc9c1e5512cec6ba323c4d324d0ad964fd778dc00a01e79c21066e53a6fe"></a>badDecode&#160;</td><td class="fielddoc"><p><a class="el" href="classwamp_1_1_error.html" title="Provides the reason URI, options, and payload arguments contained within WAMP ERROR messages.">Error</a> decoding WAMP message payload. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ce4bc9c1e5512cec6ba323c4d324d0a3b2142dd13569c21d672bb57b522b590"></a>badSchema&#160;</td><td class="fielddoc"><p>Invalid WAMP message schema. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ce4bc9c1e5512cec6ba323c4d324d0af44cec05923311221b1a36fc299fc124"></a>unsupportedMsg&#160;</td><td class="fielddoc"><p>Received unsupported WAMP message. </p>
</td></tr>
<tr><td class="fieldname"><a id="a19ce4bc9c1e5512cec6ba323c4d324d0a310cdeee6d2ef9c459c211b39a06d465"></a>unexpectedMsg&#160;</td><td class="fielddoc"><p>Received unexpected WAMP message. </p>
</td></tr>
</table>

</div>
</div>
<a id="a7a09562b29d4b6e42e37be77ec31829a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a09562b29d4b6e42e37be77ec31829a">&#9670;&nbsp;</a></span>TransportErrc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a7a09562b29d4b6e42e37be77ec31829a">wamp::TransportErrc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error code values used with the <a class="el" href="classwamp_1_1_transport_category.html" title="std::error_category used for reporting errors at the transport layer.">TransportCategory</a> error category. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7a09562b29d4b6e42e37be77ec31829aa260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Operation successful. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a09562b29d4b6e42e37be77ec31829aadfb7069bfc6e0064a6c667626eca07b4"></a>aborted&#160;</td><td class="fielddoc"><p>Operation aborted. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a09562b29d4b6e42e37be77ec31829aa26934eb377001f66e37289a5c93fe284"></a>failed&#160;</td><td class="fielddoc"><p>Operation failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a09562b29d4b6e42e37be77ec31829aab9c1fb72d859b4927608fb262096783a"></a>badTxLength&#160;</td><td class="fielddoc"><p>Outgoing message exceeds maximum length. </p>
</td></tr>
<tr><td class="fieldname"><a id="a7a09562b29d4b6e42e37be77ec31829aa0e4488fc267b2d8dad253ab78f5b9e8c"></a>badRxLength&#160;</td><td class="fielddoc"><p>Incoming message exceeds maximum length. </p>
</td></tr>
</table>

</div>
</div>
<a id="aa0bf722cbe7ad04d49ad94b6ec440541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0bf722cbe7ad04d49ad94b6ec440541">&#9670;&nbsp;</a></span>RawsockErrc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#aa0bf722cbe7ad04d49ad94b6ec440541">wamp::RawsockErrc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error code values used with the <a class="el" href="classwamp_1_1_rawsock_category.html" title="std::error_category used for reporting errors specific to raw socket transports.">RawsockCategory</a> error category. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541a260ca9dd8a4577fc00b7bd5810298076"></a>success&#160;</td><td class="fielddoc"><p>Operation succesful. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541aa5e02f2492945f6f4616d60c7bf0f441"></a>badSerializer&#160;</td><td class="fielddoc"><p>Serializer unsupported. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541acc60048c7f1cfedb42fb691a65560754"></a>badMaxLength&#160;</td><td class="fielddoc"><p>Maximum message length unacceptable. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541abb289e45a93481a3f9d352d606b24a52"></a>reservedBitsUsed&#160;</td><td class="fielddoc"><p>Use of reserved bits (unsupported feature) </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541a8e5cd4823b78ba1dbe5615f8a72cc451"></a>maxConnectionsReached&#160;</td><td class="fielddoc"><p>Maximum connection count reached. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541af55842d15f31953fa4b495f84937ab40"></a>badHandshake&#160;</td><td class="fielddoc"><p>Invalid handshake format from peer. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa0bf722cbe7ad04d49ad94b6ec440541a9a41b8fb027b252366984a29cb58423b"></a>badMessageType&#160;</td><td class="fielddoc"><p>Invalid message type. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1750e952cec62e645c6b1c918c06993f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1750e952cec62e645c6b1c918c06993f">&#9670;&nbsp;</a></span>RawsockMaxLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a1750e952cec62e645c6b1c918c06993f">wamp::RawsockMaxLength</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerators used to specify the maximum length of messages that a raw socket transport can receive. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa23ccc75192d274e4baa1390df758b7a9"></a>B_512&#160;</td><td class="fielddoc"><p>512 bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa95820889c57ed2e14f37a3d40b04d3eb"></a>kB_1&#160;</td><td class="fielddoc"><p>1 kilobyte </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993faedc30900c1b9071feb2b244109a8c25b"></a>kB_2&#160;</td><td class="fielddoc"><p>2 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa8383e4e8f8e6f97da2665c52a0b31440"></a>kB_4&#160;</td><td class="fielddoc"><p>4 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa0df6f473c642920931b17d3866531994"></a>kB_8&#160;</td><td class="fielddoc"><p>8 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa23606eba3869aa06ec21f65a6af4f9f9"></a>kB_16&#160;</td><td class="fielddoc"><p>16 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa8ac627000912010efd3beece803acb81"></a>kB_32&#160;</td><td class="fielddoc"><p>32 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fad79bc0f95213a9b2d654ac146dff2811"></a>kB_64&#160;</td><td class="fielddoc"><p>64 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa186d40edc766c000a01178d48d5cbe37"></a>kB_128&#160;</td><td class="fielddoc"><p>128 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993faad8383143d8cf1211f5563836fd49633"></a>kB_256&#160;</td><td class="fielddoc"><p>256 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa14a233b47cc592c5ca2e0c8f9a491819"></a>kB_512&#160;</td><td class="fielddoc"><p>512 kilobytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa7e97e2cb92202bee510f8f60c8a1731f"></a>MB_1&#160;</td><td class="fielddoc"><p>1 megabyte </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa068279e2835919ba1c26a15639f88417"></a>MB_2&#160;</td><td class="fielddoc"><p>2 megabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa2f62273b1b6d374490403fa82249244c"></a>MB_4&#160;</td><td class="fielddoc"><p>4 megabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fa36fbb1a264212a9d7d50718ab388cdae"></a>MB_8&#160;</td><td class="fielddoc"><p>8 megabytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a1750e952cec62e645c6b1c918c06993fab6907cabd72d2874a3bfbfce2f61ba42"></a>MB_16&#160;</td><td class="fielddoc"><p>16 megabytes </p>
</td></tr>
</table>

</div>
</div>
<a id="a4d04d75506649324abb78e785749ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d04d75506649324abb78e785749ccdb">&#9670;&nbsp;</a></span>TypeId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a4d04d75506649324abb78e785749ccdb">wamp::TypeId</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integer ID used to indicate the current dynamic type of a <code><a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdba37a6259cc0c1dae299a7866489dff0bd"></a>null&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#ad648e1d34a73e96ced2d8ffbb275aece" title="Represents an empty value.">Variant::Null</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdba84e2c64f38f78ba3ea5c905ab5a2da27"></a>boolean&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a67ff11240850f948d45f252b447283de" title="Boolean type.">Variant::Bool</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdba157db7df530023575515d366c9b672e8"></a>integer&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a28b6c65a98ecc9997633531b2adb46ba" title="Signed integer type.">Variant::Int</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdba1277b8d5127d0eced2e9d3b99a3a7079"></a>uint&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a5c1c68c19533ed9cc5bc8d3f2ad851b7" title="Unsigned integer type.">Variant::UInt</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdba4bca24304861acde5770fdbe3cc2503b"></a>real&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a8e687f0bddbab0fcb700524ce9bf7a5d" title="Floating-point number type.">Variant::Real</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdbab45cffe084dd3d20d928bee85e7b0f21"></a>string&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a4b5acc21504a3a896d2c51266c25865e" title="String type.">Variant::String</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdbaee26908bf9629eeb4b37dac350f4754a"></a>blob&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a64cfaff2b583e1d96dd6417712abe554" title="Binary data as an array of bytes.">Variant::Blob</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdbaf1f713c9e000f5d3f280adbd124df4f5"></a>array&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a4d04d75506649324abb78e785749ccdbaa8cfde6331bd59eb2ac96f8911c4b666"></a>object&#160;</td><td class="fielddoc"><p>For <a class="el" href="classwamp_1_1_variant.html#ac05ea01a41e8484356f1812daadf7346" title="Dictionary of variants.">Variant::Object</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a53ba5f85cd0d02bf363dfec7da1b339f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ba5f85cd0d02bf363dfec7da1b339f">&#9670;&nbsp;</a></span>SessionState</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#a53ba5f85cd0d02bf363dfec7da1b339f">wamp::SessionState</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the possible states that a client or router session can be in. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fa3a561116f0c9675a3c83d21fa365050d"></a>disconnected&#160;</td><td class="fielddoc"><p>The transport connection is not yet established. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fa9a27316fbc5ef38b2a19c202dbdc29b7"></a>connecting&#160;</td><td class="fielddoc"><p>Transport connection is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fa349e686330723975502e9ef4f939a5ac"></a>closed&#160;</td><td class="fielddoc"><p>Transport connected, but WAMP session is closed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339faab0e76e1623e4b9f4b2c6dc8e966989f"></a>establishing&#160;</td><td class="fielddoc"><p>WAMP session establishment is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fa3d5d0f5c7a6b281da0b22f8c128fb20e"></a>authenticating&#160;</td><td class="fielddoc"><p>WAMP authentication is in progress. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339faa533b26cba9a7c8d891c962473f49ec0"></a>established&#160;</td><td class="fielddoc"><p>WAMP session is established. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fabe3d0ab12e871a97c27100d4a3183ec2"></a>shuttingDown&#160;</td><td class="fielddoc"><p>WAMP session is closing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a53ba5f85cd0d02bf363dfec7da1b339fa26934eb377001f66e37289a5c93fe284"></a>failed&#160;</td><td class="fielddoc"><p>WAMP session or transport connection has failed. </p>
</td></tr>
</table>

</div>
</div>
<a id="ada5fff4d6df9508a521ce3966a80f402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5fff4d6df9508a521ce3966a80f402">&#9670;&nbsp;</a></span>CallCancelMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacewamp.html#ada5fff4d6df9508a521ce3966a80f402">wamp::CallCancelMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates the possible call cancelling modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada5fff4d6df9508a521ce3966a80f402a534735884d341071762ede7af01c53e8"></a>kill&#160;</td><td class="fielddoc"><p>INTERRUPT sent to callee; RESULT or ERROR returned, depending on callee. </p>
</td></tr>
<tr><td class="fieldname"><a id="ada5fff4d6df9508a521ce3966a80f402a242f6238202bc24d24474f1b405f6bb7"></a>killNoWait&#160;</td><td class="fielddoc"><p>INTERRUPT sent to callee; router immediately returns ERROR. </p>
</td></tr>
<tr><td class="fieldname"><a id="ada5fff4d6df9508a521ce3966a80f402a08b43519a7e36ee4c6c5615d1663bcfd"></a>skip&#160;</td><td class="fielddoc"><p>No INTERRUPT sent to callee; router immediately returns ERROR. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a47bb6673f3bae26c63ab24239194bc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bb6673f3bae26c63ab24239194bc75">&#9670;&nbsp;</a></span>encode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFormat , typename TOutput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::encode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutput &amp;&amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given variant to the given byte container or stream. </p>
<p>By design, the output is not cleared before encoding. The encoder is instantiated once and then discarded. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFormat</td><td>The codec format tag (e.g. <a class="el" href="structwamp_1_1_json.html" title="JSON format tag type.">Json</a>) </td></tr>
    <tr><td class="paramname">TOutput</td><td>The output type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewamp.html#a2a2f8f640e5157d6bc85fe8ba79224ac" title="Decodes from the given byte sequence or stream to the given variant.">wamp::decode</a> </dd>
<dd>
<a class="el" href="namespacewamp.html#a3a4f63f74b0ede851c60223ecf3674e5" title="Yields the encoder type needed to encode a Variant to the given output type and output category.">wamp::Encoder</a> </dd></dl>

</div>
</div>
<a id="a2a2f8f640e5157d6bc85fe8ba79224ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2f8f640e5157d6bc85fe8ba79224ac">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFormat , typename TInput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::error_code wamp::decode </td>
          <td>(</td>
          <td class="paramtype">TInput &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_variant.html">Variant</a> &amp;&#160;</td>
          <td class="paramname"><em>variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes from the given byte sequence or stream to the given variant. </p>
<p>The decoder is instantiated once and then discarded. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFormat</td><td>The codec format tag (e.g. <a class="el" href="structwamp_1_1_json.html" title="JSON format tag type.">Json</a>) </td></tr>
    <tr><td class="paramname">TInput</td><td>The input type (deduced) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::error_code indicating success or failure </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacewamp.html#a47bb6673f3bae26c63ab24239194bc75" title="Encodes the given variant to the given byte container or stream.">wamp::encode</a> </dd>
<dd>
<a class="el" href="namespacewamp.html#a612977014a4cf2e1d8f58406b95d0e6e" title="Yields the decoder type needed to decode a Variant from the given input type and input category.">wamp::Decoder</a> </dd></dl>

</div>
</div>
<a id="afc8cfc7a90d578f0536d7368bcc2d207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8cfc7a90d578f0536d7368bcc2d207">&#9670;&nbsp;</a></span>basicCoroEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TArgs, typename TSlot &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwamp_1_1_simple_coro_event_unpacker.html">SimpleCoroEventUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TArgs... &gt; wamp::basicCoroEvent </td>
          <td>(</td>
          <td class="paramtype">TSlot &amp;&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Use simpleCoroEvent instead.</dd></dl>

</div>
</div>
<a id="a77f603aa9cb27a3ae0ab1f8f8ddec1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f603aa9cb27a3ae0ab1f8f8ddec1dc">&#9670;&nbsp;</a></span>basicCoroRpc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TResult , typename... TArgs, typename TSlot &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwamp_1_1_simple_coro_invocation_unpacker.html">SimpleCoroInvocationUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TResult, TArgs... &gt; wamp::basicCoroRpc </td>
          <td>(</td>
          <td class="paramtype">TSlot &amp;&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use simpleCoroRpc instead.</dd></dl>

</div>
</div>
<a id="a0f60ee29904aa30973713672aa3fc37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f60ee29904aa30973713672aa3fc37b">&#9670;&nbsp;</a></span>isNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool wamp::isNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given type is considered a number. </p>
<dl class="section note"><dt>Note</dt><dd>To be consitent with Javascript's strict equality, a boolean is not considered a number, </dd></dl>

</div>
</div>
<a id="ae2d94efc6083f316ca03b828d2a64fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d94efc6083f316ca03b828d2a64fd8">&#9670;&nbsp;</a></span>basicEvent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TArgs, typename TSlot &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwamp_1_1_simple_event_unpacker.html">SimpleEventUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TArgs... &gt; wamp::basicEvent </td>
          <td>(</td>
          <td class="paramtype">TSlot &amp;&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000049">Deprecated:</a></b></dt><dd>Use simpleEvent instead.</dd></dl>

</div>
</div>
<a id="add2b0875bbaf5d9605135d405a43a7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2b0875bbaf5d9605135d405a43a7ea">&#9670;&nbsp;</a></span>basicRpc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TResult , typename... TArgs, typename TSlot &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwamp_1_1_simple_invocation_unpacker.html">SimpleInvocationUnpacker</a>&lt; <a class="el" href="namespacewamp.html#afb68057439fa3d32bb02ac8d707206fc">DecayedSlot</a>&lt; TSlot &gt;, TResult, TArgs... &gt; wamp::basicRpc </td>
          <td>(</td>
          <td class="paramtype">TSlot &amp;&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>Use wamp::simpleRpc instead.</dd></dl>

</div>
</div>
<a id="a9a84cb7bb559428594ebfb21c07a8935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a84cb7bb559428594ebfb21c07a8935">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TConverter , typename TValue , DisableIf&lt; std::is_enum&lt; TValue &gt;::value &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype">TConverter &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General function for converting custom types to/from <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>. </p>
<p>You must overload this function for custom types that you want to be convertible to/from <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>. Alternatively, you may also:</p><ul>
<li>provide a <code>convert</code> member function within your custom type,</li>
<li>use <a class="el" href="variant_8hpp.html#aff26c9fdce903efd0485b1d204691f5d">CPPWAMP_CONVERSION_SPLIT_FREE</a> and provide split <code>convertTo</code> and <code>convertFrom</code> free functions, or,</li>
<li>use <a class="el" href="variant_8hpp.html#af771a3a82d12fcbe7d2c412afc719fc7">CPPWAMP_CONVERSION_SPLIT_MEMBER</a> and provide split <code>convertTo</code> and <code>convertFrom</code> member functions. </li>
</ul>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="examples_2asynctimeclient_2main_8cpp-example.html#a0">examples/asynctimeclient/main.cpp</a>, <a class="el" href="examples_2asynctimeservice_2main_8cpp-example.html#a0">examples/asynctimeservice/main.cpp</a>, <a class="el" href="examples_2coro20timeclient_2main_8cpp-example.html#a0">examples/coro20timeclient/main.cpp</a>, <a class="el" href="examples_2coro20timeservice_2main_8cpp-example.html#a0">examples/coro20timeservice/main.cpp</a>, <a class="el" href="examples_2futuretimeclient_2main_8cpp-example.html#a0">examples/futuretimeclient/main.cpp</a>, <a class="el" href="examples_2futuretimeservice_2main_8cpp-example.html#a0">examples/futuretimeservice/main.cpp</a>, <a class="el" href="examples_2stacklesstimeclient_2main_8cpp-example.html#a0">examples/stacklesstimeclient/main.cpp</a>, <a class="el" href="examples_2stacklesstimeservice_2main_8cpp-example.html#a0">examples/stacklesstimeservice/main.cpp</a>, <a class="el" href="examples_2timeclient_2main_8cpp-example.html#a0">examples/timeclient/main.cpp</a>, and <a class="el" href="examples_2timeservice_2main_8cpp-example.html#a0">examples/timeservice/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a3d7124cf7175556a3c2190d860bf1416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7124cf7175556a3c2190d860bf1416">&#9670;&nbsp;</a></span>lookupWampErrorUri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool wamp::lookupWampErrorUri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">SessionErrc</a>&#160;</td>
          <td class="paramname"><em>fallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacewamp.html#a9ecf2a0b15a4d67bb0cd1928b4056d46">SessionErrc</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>'true' if the corresponding error code was found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">uri</td><td>The URI to search under. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">fallback</td><td>Defaul value to used if the URI was not found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>[out] The error code corresponding to the given URI, or the given fallback value if not found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cffe721e4c495c1733c6985b894db1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cffe721e4c495c1733c6985b894db1c">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from an array variant to a <code>std::array</code>. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="a06fae3bba144889572782ffc020cd8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fae3bba144889572782ffc020cd8f5">&#9670;&nbsp;</a></span>convert() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, Size &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a <code>std::array</code> to an array variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="a4d10382ab0957a5457c4e48dfad3ee58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d10382ab0957a5457c4e48dfad3ee58">&#9670;&nbsp;</a></span>convert() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a variant to a boost::optional. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="ad99c56e5890f2b65b900921126dfba32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99c56e5890f2b65b900921126dfba32">&#9670;&nbsp;</a></span>convert() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a boost::optional to a variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="aa61f3f98c3d797a8610ccb20d9d68394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61f3f98c3d797a8610ccb20d9d68394">&#9670;&nbsp;</a></span>convert() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a variant to a std::optional. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="a306f456b677ab40e11b6fa0f21d709fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306f456b677ab40e11b6fa0f21d709fa">&#9670;&nbsp;</a></span>convert() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a std::optional to a variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="ac455de8fa2a3e27d049f0ee03984b840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac455de8fa2a3e27d049f0ee03984b840">&#9670;&nbsp;</a></span>convert() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from an array variant to a <code>std::set</code>. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="ae40665234ed11137bdf50ab60bd8f16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40665234ed11137bdf50ab60bd8f16e">&#9670;&nbsp;</a></span>convert() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a <code>std::set</code> to an array variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="a0cb775430355bc3fde2a4661fc3e61a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb775430355bc3fde2a4661fc3e61a8">&#9670;&nbsp;</a></span>toTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::toTuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7">wamp::Variant::Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a> to a <code>std::tuple</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The Array's element types must be convertible to the tuple's element types. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structwamp_1_1error_1_1_conversion.html" title="Exception type thrown when converting a Variant to an invalid type.">error::Conversion</a></td><td>if one of the Array element types is not convertible to the target type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9085e81db59addf5d9fe854a01a993b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9085e81db59addf5d9fe854a01a993b7">&#9670;&nbsp;</a></span>toArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7">wamp::Variant::Array</a> wamp::toArray </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <code>std::tuple</code> to a <a class="el" href="classwamp_1_1_variant.html#a5bce903eff7946f4a375cc6bb5953bb7" title="Dynamic array of variants.">Variant::Array</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The tuple values must be convertible to <a class="el" href="classwamp_1_1_variant.html" title="Discriminated union container that represents a JSON value.">Variant</a>'s bound types (statically checked). </dd></dl>

</div>
</div>
<a id="a0ece744d0f89e28b123b8cbf71bbdf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ece744d0f89e28b123b8cbf71bbdf42">&#9670;&nbsp;</a></span>convert() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from an array variant to a <code>std::tuple</code>. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="a93a81787bdd89c19d7094756e3e50895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a81787bdd89c19d7094756e3e50895">&#9670;&nbsp;</a></span>convert() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a <code>std::tuple</code> to an array variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="a3de3a8ab4349a5856300872d3e9e8761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de3a8ab4349a5856300872d3e9e8761">&#9670;&nbsp;</a></span>convert() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="namespacewamp.html#a0b58ab2a2761bca711bc957b47619662">String</a>, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from an object variant to a <code>std::unordered_map</code>. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="adfc3e63b825b5f6c3fbe497b76d8ef71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc3e63b825b5f6c3fbe497b76d8ef71">&#9670;&nbsp;</a></span>convert() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; <a class="el" href="namespacewamp.html#a0b58ab2a2761bca711bc957b47619662">String</a>, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a <code>std::unordered_map</code> to an object variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
<a id="a7490642dafbab110c4eda5cd77022f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7490642dafbab110c4eda5cd77022f1e">&#9670;&nbsp;</a></span>convert() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_from_variant_converter.html">FromVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from an array variant to a <code>std::unordered_set</code>. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#ac59c2a98e2df7cb38ba7b13e2085ac9c" title="Converts the variant&#39;s bound value to the given type.">Variant::to</a> instead. </p>

</div>
</div>
<a id="a27a21a5d6aa3174b2b32bf147210413c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a21a5d6aa3174b2b32bf147210413c">&#9670;&nbsp;</a></span>convert() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void wamp::convert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwamp_1_1_to_variant_converter.html">ToVariantConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>conv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the conversion from a <code>std::unordered_set</code> to an array variant. </p>
<p>Users should not use this function directly. Use <a class="el" href="classwamp_1_1_variant.html#aefe87e6ea0e056086ac71938907d58e4" title="Constructs a variant from a custom type.">Variant::from</a> instead. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewamp.html">wamp</a></li>
    <li class="footer">Generated on Sat Aug 13 2022 20:54:39 for CppWAMP by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
