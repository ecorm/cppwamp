/*------------------------------------------------------------------------------
    Copyright Butterfly Energy Systems 2023.
    Distributed under the Boost Software License, Version 1.0.
    http://www.boost.org/LICENSE_1_0.txt
------------------------------------------------------------------------------*/

/**
@page StreamingTutorial Streaming

@tableofcontents

This library's streaming API is a facade over WAMP's
[Progressive Call Results][1] and [Progressive Call Invocations][2] features.
The streaming API does not provide another layer on top of WAMP, but rather,
abstracts away some of the complexities of those advanced features. This API
includes optional provisions for in-band signaling. An application can
implement more sophisticated streaming by using this API as a building block.


Stream Slots
------------

CppWamp allows you to register handler functions that will be executed whenever
a stream with a certain URI is initiated remotely by a dealer. Such callback
functions are named _stream slots_. Stream slots can be any callable entity that
can be stored into a [`std::function`][3]:
- free functions,
- member functions (via [`std::bind`][4]),
- function objects,
- lambdas, etc.

The signature of these slots is expected to be of the form:

```
void function(wamp::CalleeChannel::Ptr)
```
where:
- wamp::CalleeChannel::Ptr is a shared pointer to a channel object used
  for further interaction with the stream


Binding Executors to Stream Slots
---------------------------------

TODO: Write me


Registering a Stream
--------------------

Callees may register a stream associated with an URI, with a _stream slot_
that will be invoked upon a caller initiating a new stream instance.

A wamp::CalleeChannel is passed via the stream slot which allows the
callee to interact with the stream. Such interaction includes

- accepting or rejecting the streaming request
- registering handler functions for chunks and interruptions sent by the caller
- returning intermediate and final chunks back to the caller

The following example shows a callee registering a stream that sends
back chunks at fixed time intervals:

```
#include <boost/asio/steady_timer.hpp>
#include <cppwamp/json.hpp>
#include <cppwamp/session.hpp>
#include <cppwamp/spawn.hpp>
#include <cppwamp/tcp.hpp>

int main()
{
    IoContext ioctx;
    Session session(ioctx);
    std::set<RequestId> interruptions;

    auto onInterrupt =
        [&interruptions](CalleeChannel::Ptr channel, Interruption intr)
    {
        // Make the coroutine in the countdown function break out of its loop.
        interruptions.insert(intr.requestId());
        channel->fail("wamp.error.canceled");
    }

    auto countdownStream = [](CalleeChannel::Ptr channel)
    {
        spawn(ioctx, [channel, &ioctx](YieldContext yield)
        {
            // Accept the invitation and return an RSVP, while providing
            // an interruption handler.
            channel->accept(CalleeOutputChunk().withArgs("ok"),
                            {}, // No chunks from caller expected
                            onInterrupt);

            // Obtain the count from a positional argument contained in the
            // invitation that was sent by the caller.
            unsigned count = 0;
            channel->invitation().convertTo(count);

            boost::asio::steady_timer timer(ioctx);
            auto deadline = std::chrono::steady_clock::now();

            while (count > 0)
            {
                // Break out of the loop if this stream was interrupted.
                if (interruptions.erase(channel->id()) != 0)
                    return;

                // Delay for one second.
                timer.expires_at(deadline += std::chrono::seconds(1));
                timer.async_wait(yield);

                // Return intermediate result chunks
                channel->send(CalleeOutputChunk().withArgs(count));

                --count;
            }

            // Return the final result chunk, which closes the channel
            channel->send(CalleeOutputChunk(true).withArgs(count));
        });
    }

    spawn(ioctx, [&session](YieldContext yield)
    {
        auto tcp = TcpHost{"localhost", 8001}.withFormat(json);
        session.connect(std::move(tcp), yield).value();
        session.join(Realm("somerealm"), yield).value();
        session.enroll(Stream("countdown"), countdown, yield).value();
    });

    ioctx.run();
    return 0;
}
```

Chunk Slots
-----------

_Chunk slots_ are handler functions provided by a caller to process stream
chunks returned by a callee.

The signature of chunk slots is expected to be of the form:

```
void function(wamp::CallerChannel::Ptr, wamp::ErrorOr<wamp::CallerInputChunk>)
```
where:
- wamp::CallerChannel::Ptr is a shared pointer to a channel object used
  for further interaction with the stream
- wamp::CallerInputChunk contains the payload of a chunk returned by a callee


Initiating a Stream Channel
---------------------------

A caller initiates a new stream channel by calling the wamp::Session::invite
overload that takes a wamp::Invitation and a chunk slot. The `Invitation`
object contains the stream URI, the *stream mode*, as well as the invitation
payload arguments.

The stream mode determines the WAMP Progressive Call Results/Invocations
features that will be used in the `CALL` messages sent to the callee.

Streaming Mode | `progress` | `receive_progress` | `CALL` Count | `RESULT` Count
-------------- | ---------- | ------------------ | ------------ | --------------
simpleCall     | `false`    | `false`            | 1 only       | 1 only
callerToCallee | `false`    | `true`             | 1 only       | 1 or more
calleeToCaller | `true`     | `false`            | 1 or more    | 1 only
bidirectional  | `true`     | `true`             | 1 or more    | 1 or more

@note When both progressive results and invocations are disabled, this decays
      into a "simple" remote procedure call with a single invocation and a
      single result.

wamp::Session::invite will emit a wamp::CallerChannel shared pointer that
can be used for further interaction with the stream. Such interaction includes:

- accessing the RSVP the callee returned in response to the invitation
- sending intermediary and final chunks to the callee
- cancelling the stream

The following example shows a caller initiating an instance of the stream from
the previous example:

```
#include <cppwamp/json.hpp>
#include <cppwamp/session.hpp>
#include <cppwamp/spawn.hpp>
#include <cppwamp/tcp.hpp>

int main()
{
    using namespace wamp;
    IoContext ioctx;
    Session session(ioctx);
    bool done = false;

    auto onChunk = [&done](CallerChannel::Ptr, ErrorOr<CallerInputChunk> chunk)
    {
        unsigned n = 0;
        chunk.value().convertTo(n);
        std::cout << "Tick: " << n << "\n";
        done = chunk.isFinal();
    };

    spawn(ioctx, [&](YieldContext yield)
    {
        auto tcp = TcpHost{"localhost", 8001}.withFormat(json);
        session.connect(std::move(tcp), yield).value();
        session.join(Realm("somerealm"), yield).value();
        unsigned countDownFrom = 5;

        auto channel = session.invite(
            Invitation("countdown").withArgs(countDownFrom),
            yield);

        std::cout << "RSVP: " << channel->rsvp().args() << "\n";

        while (!done)
            boost::asio::post(ioctx, yield);
    });
    ioctx.run();
    return 0;
}
```

- - -

Next: @ref PubSubTutorial

[1]: https://wamp-proto.org/wamp_latest_ietf.html#name-progressive-call-results
[2]: https://wamp-proto.org/wamp_latest_ietf.html#name-progressive-calls
[3]: http://en.cppreference.com/w/cpp/utility/functional/function
[4]: http://en.cppreference.com/w/cpp/utility/functional/bind

*/
