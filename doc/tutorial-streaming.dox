/*------------------------------------------------------------------------------
    Copyright Butterfly Energy Systems 2023.
    Distributed under the Boost Software License, Version 1.0.
    http://www.boost.org/LICENSE_1_0.txt
------------------------------------------------------------------------------*/

/**
@page StreamingTutorial Streaming

@tableofcontents

CppWAMP's streaming API is a facade over WAMP's
[Progressive Call Results][1] and [Progressive Call Invocations][2] features.
It abstracts away some of the complexities of those advanced features.

See @ref Streams for an overview of the concepts behind streaming.

Stream Slots
------------

CppWamp allows you to register handler functions that will be executed whenever
a stream with a certain URI is initiated remotely by a dealer. Such callback
functions are named _stream slots_. Stream slots can be any callable entity that
can be stored into a [`std::function`][3]:
- free functions,
- member functions (via [`std::bind`][4]),
- function objects,
- lambdas, etc.

The signature of these slots is expected to be of the form:

```
void function(wamp::CalleeChannel)
```
where:
- wamp::CalleeChannel is a lightweight reference-counted proxy to a channel
  object used for further interaction with the stream


Registering a Stream
--------------------

Callees may register a stream associated with an URI, with a _stream slot_
that will be invoked upon a caller initiating a new stream instance.

A wamp::CalleeChannel is passed via the stream slot which allows the
callee to interact with the stream. Such interaction includes

- accepting or rejecting the streaming request
- registering handler functions for chunks and interruptions sent by the caller
- returning intermediate and final chunks back to the caller

The following example shows a callee registering a stream that sends
back chunks at fixed time intervals:

```
#include <boost/asio/steady_timer.hpp>
#include <cppwamp/session.hpp>
#include <cppwamp/spawn.hpp>
#include <cppwamp/codecs/json.hpp>
#include <cppwamp/transports/tcp.hpp>

int main()
{
    IoContext ioctx;
    Session session(ioctx);
    std::set<RequestId> interruptions;

    auto onInterrupt =
        [&interruptions](CalleeChannel channel, Interruption intr)
    {
        // Make the coroutine in the countdown function break out of its loop.
        interruptions.insert(intr.requestId());
        channel.fail("wamp.error.canceled");
    }

    auto countdownStream = [](CalleeChannel channel)
    {
        spawn(ioctx, [channel, &ioctx](YieldContext yield)
        {
            // Accept the invitation and return an RSVP, while providing
            // an interruption handler.
            channel.respond(CalleeOutputChunk().withArgs("ok"),
                            {}, // No chunks from caller expected
                            onInterrupt);

            // Obtain the count from a positional argument contained in the
            // invitation that was sent by the caller.
            unsigned count = 0;
            channel.invitation().convertTo(count);

            boost::asio::steady_timer timer(ioctx);
            auto deadline = std::chrono::steady_clock::now();

            while (count > 0)
            {
                // Break out of the loop if this stream was interrupted.
                if (interruptions.erase(channel.id()) != 0)
                    return;

                // Delay for one second.
                timer.expires_at(deadline += std::chrono::seconds(1));
                timer.async_wait(yield);

                // Return intermediate result chunks
                channel.send(CalleeOutputChunk().withArgs(count));

                --count;
            }

            // Return the final result chunk, which closes the channel
            channel.send(CalleeOutputChunk(true).withArgs(count));
        });
    }

    spawn(ioctx, [&session](YieldContext yield)
    {
        auto tcp = TcpHost{"localhost", 8001}.withFormat(json);
        session.connect(std::move(tcp), yield).value();
        session.join(Petition("somerealm"), yield).value();
        session.enroll(Stream("countdown"), countdown, yield).value();
    });

    ioctx.run();
    return 0;
}
```

Chunk Slots
-----------

_Chunk slots_ are handler functions provided by a caller to process stream
chunks returned by a callee.

The signature of chunk slots is expected to be of the form:

```
void function(wamp::CallerChannel, wamp::ErrorOr<wamp::CallerInputChunk>)
```
where:
- wamp::CallerChannel is a lightweight reference-counted proxy to a channel
  object used for further interaction with the stream
- wamp::CallerInputChunk contains the payload of a chunk returned by a callee


Opening a Stream Channel
------------------------

A caller opens a new stream channel by calling the wamp::Session::requestStream
overload that takes a wamp::StreamRequest and a chunk slot. The `StreamRequest`
object contains the stream URI, the *stream mode*, as well as the invitation
payload arguments.

wamp::Session::requestStream will emit a wamp::CallerChannel shared pointer that
can be used for further interaction with the stream. Such interaction includes:

- accessing the RSVP the callee returned in response to the invitation
- sending intermediary and final chunks to the callee
- cancelling the stream

The following example shows a caller opening a a stream from the
previous example:

```
#include <cppwamp/session.hpp>
#include <cppwamp/spawn.hpp>
#include <cppwamp/codecs/json.hpp>
#include <cppwamp/transports/tcp.hpp>

int main()
{
    using namespace wamp;
    IoContext ioctx;
    Session session(ioctx);
    bool done = false;

    auto onChunk = [&done](CallerChannel, ErrorOr<CallerInputChunk> chunk)
    {
        unsigned n = 0;
        chunk.value().convertTo(n);
        std::cout << "Tick: " << n << "\n";
        done = chunk.isFinal();
    };

    spawn(ioctx, [&](YieldContext yield)
    {
        auto tcp = TcpHost{"localhost", 8001}.withFormat(json);
        session.connect(std::move(tcp), yield).value();
        session.join(Petition("somerealm"), yield).value();
        unsigned countDownFrom = 5;

        auto channel = session.requestStream(
            StreamRequest("countdown").withArgs(countDownFrom),
            yield);

        std::cout << "RSVP: " << channel.rsvp().args() << "\n";

        while (!done)
            boost::asio::post(ioctx, yield);
    });
    ioctx.run();
    return 0;
}
```

- - -

Next: @ref AsyncCallbacksTutorial

[1]: https://wamp-proto.org/wamp_latest_ietf.html#name-progressive-call-results
[2]: https://wamp-proto.org/wamp_latest_ietf.html#name-progressive-calls
[3]: http://en.cppreference.com/w/cpp/utility/functional/function
[4]: http://en.cppreference.com/w/cpp/utility/functional/bind

*/
