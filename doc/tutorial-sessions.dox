/*------------------------------------------------------------------------------
              Copyright Butterfly Energy Systems 2014-2015, 2022.
           Distributed under the Boost Software License, Version 1.0.
              (See accompanying file LICENSE_1_0.txt or copy at
                    http://www.boost.org/LICENSE_1_0.txt)
------------------------------------------------------------------------------*/

/**
@page SessionsTutorial Sessions

@tableofcontents

Because it makes things easier to demonstrate, the following tutorial pages
will use the coroutine-based session API. The asynchronous session API is
covered in @ref AsyncTutorial.

Creating the Session Object
---------------------------

Once one or more wamp::Connector objects have been created, they are passed to
the @ref wamp::CoroSession::create "create" factory method of the session API.
`create` then returns a `std::shared_ptr` to the newly created
wamp::CoroSession object.

```
#include <cppwamp/corosession.hpp>
#include <cppwamp/json.hpp>
#include <cppwamp/msgpack.hpp>
#include <cppwamp/tcp.hpp>
using namespace wamp;

AsioContext ioctx;
auto tcpJson = connector<Json>(ioctx, TcpHost("localhost", 8001));
auto tcpPack = connector<Msgpack>(ioctx, TcpHost("localhost", 8001));

// Create the Session object:
auto session = CoroSession<>::create(ioctx, {tcpJson, tcpPack});
```

Connecting and Joining
----------------------

After the session object is created, the
@ref wamp::CoroSession::connect "connect" operation is used to establish a
transport connection to a WAMP router. The
@ref wamp::CoroSession::join "join" operation is then used to join a WAMP realm
on the router.

All "blocking" operations of `CoroSession` must be executed within the context
of a _coroutine_. Coroutines are initiated via [boost::asio::spawn]
(https://www.boost.org/doc/libs/release/doc/html/boost_asio/reference/spawn.html).
For any `CoroSession` operation that needs to "block" until completion, a
_yield context_ must be provided. The following example shows how to spawn a
coroutine, and how a yield context is passed to the `connect` and `join`
operations.

```
using namespace wamp;
AsioContext ioctx;
auto tcpJson = connector<Json>(ioctx, TcpHost("localhost", 8001));
auto tcpPack = connector<Msgpack>(ioctx, TcpHost("localhost", 8001));

boost::asio::spawn(ioctx, [&](boost::asio::yield_context yield)
{
    auto session = CoroSession<>::create(ioctx, {tcpJson, tcpPack});
    session->connect(yield);
    auto sessionInfo = session->join(Realm("somerealm"), yield);
    // etc.
});

ioctx.run();

```

Note that while a coroutine operation is suspended, it yields control so that
other asynchronous operations can be executed via the I/O context.

Leaving and Disconnecting
-------------------------

To gracefully end a WAMP session, the @ref wamp::CoroSession::leave "leave" and
@ref wamp::CoroSession::disconnect "disconnect" operations are used:

```
using namespace wamp;
boost::asio::spawn(ioctx, [&](boost::asio::yield_context yield)
{
    auto session = CoroSession<>::create(ioctx, {tcpJson, tcpPack});
    session->connect(yield);
    session->join(Realm("somerealm"), yield);

    while (!finished)
    {
        // Interact with the WAMP session
    }

    auto reason = session->leave(yield); // returns the Reason URI and
                                         // other details from the router's
                                         // GOODBYE message
    session->disconnect(); // non-blocking
});
```

To abruptly end a WAMP session, you can skip the `leave` operation and just
`disconnect`. This may be useful when handling error conditions. Alternatively,
you can let the session `shared_ptr` reference count drop to zero, and the
session will abruptly terminate the connection in its destructor:

```
using namespace wamp;
boost::asio::spawn(ioctx, [&](boost::asio::yield_context yield)
{
    auto session = CoroSession<>::create(ioctx, {tcpJson, tcpPack});
    session->connect(yield);
    session->join(Realm("somerealm"), yield);

    while (!finished)
    {
        // Interact with the WAMP session
    }

    // The session reference count will drop to zero when this lambda
    // function exits. The session destructor will then terminate the
    // connection.
});
```

Logging
-------

`wamp::Session` and `wamp::CoroSession` can generate log events at
runtime, for warnings and for inbound/outbound WAMP messages. CppWAMP
is not opinionated about where the log events should go, so it provides
the @ref wamp::Session::setWarningHandler "setWarningHandler" and
@ref wamp::Session::setTraceHandler "setTraceHandler" methods that
allow you to register handlers for these log events.

Warnings are generated when there are problems detected that don't
prevent CppWAMP from performing its job.

Traces contain a stringified version of the WAMP protocol messages.
They can be useful for troubleshooting without having to set up
a network analyzer.

Both warning and trace handlers must be callable entities with the
signature:
```
void handler(std::string)
```

The handlers are posted via the executor that was passed to the
session's `create` method.

With these handlers you may, for example, log the messages to the
console.

```
auto session = wamp::CoroSession<>::create(ioctx, tcp);

session->setWarningHandler([](std::string message)
{
    std::cerr << "CppWAMP warning: " << message << "\n";
});

session->setTraceHandler([](std::string message)
{
    std::clog << "WAMP message: " << message << "\n";
});

```

Authentication
--------------

CppWAMP supports the `AUTHENTICATE` and `CHALLENGE` messages used for WAMP
authentication. Algorithms for computing the cryptographic signatures needed
for the WAMP-CRA and WAMP-SCRAM methods are currently not provided by CppWAMP.
CppWAMP users must therefore compute these themselves using other cryptographic
libraries. Once computed, the signatures can be passed to CppWAMP via
wamp::Authentication.

To enable authentication, you must set the challenge handler via
wamp::Session::setChallengeHandler. The handler must be a callable entity
with the following signature:

```
void handler(wamp::Challenge)
```

Within the challenge handler, you must compute the cryptographic signature
(or ticket string) and send it back via wamp::Challenge::authenticate.

When later performing the session join operation, you must set the
authentication ID via wamp::Realm::withAuthId, as well as the
desired/supported authentication methods via wamp::Realm::withAuthMethods.

The following example shows how to perform ticket authentication.

```
std::string ticket;

void onChallenge(wamp::Challenge challenge)
{
    if (challenge.method() == "ticket")
        challenge.authenticate(wamp::Authentication(ticket));
    else
        throw std::runtime_error("Unsupported authentication method");
}

int main()
{
    using namespace wamp;
    AsioContext ioctx;
    auto tcp = connector<Json>(ioctx, TcpHost("localhost", 8001));

    boost::asio::spawn(ioctx, [&](boost::asio::yield_context yield)
    {
        ticket = "guest";
        auto session = CoroSession<>::create(ioctx, tcp);
        session->setChallengeHandler(&onChallenge);
        session->connect(yield);
        auto sessionInfo = session->join(
            Realm("somerealm").withAuthId("alice").withAuthMethods({"ticket"}),
            yield);
        ticket.clear();
        // etc.
    });

    ioctx.run();

    return 0;
}
```

Handling Session State Changes
------------------------------

wamp::Session::setStateChangeHandler can be used to register a function that's
called whenever the session's wamp::SessionState changes. This can be used,
for example, to attempt reconnection when the session is disconnected due to a
network failure.

```
void rejoinSession(CoroSession<>& session, boost::asio::yield_context yield)
{
    session.connect(yield);
    session.join(Realm("somerealm", yield);
    // Register RPCs, subscribe to topics, etc.
}

void onStateChange(SessionState state,
                   std::weak_ptr<CoroSession<>> weakSession)
{
    if (state == SessionState::disconnected ||
        state == SessionState::failed)
    {
        auto session = weakSession.lock();
        if (session)
        {
            boost::asio::spawn(session->userExecutor(),
                               [session](boost::asio::yield_context yield)
            {
                // You may want to throttle and limit the reconnection
                // attempts here.
                rejoinSession(*session, yield);
            });
        }
    }
}

int main()
{
    using namespace wamp;
    AsioContext ioctx;
    auto tcp = connector<Json>(ioctx, TcpHost("localhost", 8001));

    boost::asio::spawn(ioctx, [&](boost::asio::yield_context yield)
    {
        auto session = CoroSession<>::create(ioctx, tcp);
        auto weakSession = std::weak_ptr<CoroSession<>>(session);
        session->setStateChangeHandler(
            [weakSession, ioctx](SessionState state)
            {
                onStateChange(state, weakSession);
            });
        rejoinSession(*session, yield);
       // etc.
    });

    ioctx.run();

    return 0;
}
```


- - -

Next: @ref ErrorsTutorial

*/
